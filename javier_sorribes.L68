0000128E Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/18/2017 00:36:44

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 0A 0D 4D 4F 4E 49 ...     11  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
0000103A= 49 4E 56 41 4C 49 ...     12  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
0000104B= 54 79 70 65 20 48 ...     13              DC.B    'Type HELP for command usage',0
00001067                            14  
00001067= 34 48 45 4C 50 00         15  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000106D= 34 4D 44 53 50 20         16              DC.B    '4MDSP',$20  ; number specifies length of word 
00001073= 35 53 4F 52 54 57 20      17              DC.B    '5SORTW',$20    ; used for SEARCH (not input)
0000107A= 32 4D 4D 00               18              DC.B    '2MM',0
0000107E= 34 45 58 49 54 00         19              DC.B    '4EXIT',0
00001084                            20              
00001084= 12FC                      21  COM_ADDR    DC.W    HELP        ; Command addresses table
00001086= 1310                      22              DC.W    MDSP
00001088= 1392                      23              DC.W    SORTW
0000108A= 141A                      24              DC.W    MM
0000108C= 141C                      25              DC.W    EXIT
0000108E                            26              
0000108E= 48 45 4C 50 3A 20 ...     27  HELP_MSG    DC.B    'HELP: Displays This Message',$A,$A,$D
000010AC= 4D 44 53 50 3A 20 ...     28              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
000010D7= 44 65 66 61 75 6C ...     29              DC.B    'Default address2: address1 + 16',$A,$D
000010F8= 4D 44 53 50 20 3C ...     30              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
0000112E= 53 4F 52 54 57 3A ...     31              DC.B    'SORTW: Sorts Unsigned Words In A Memory Block',$A,$D
0000115D= 42 6F 74 68 20 61 ...     32              DC.B    'Both address1 and address2 are inclusive',$A,$D
00001187= 44 65 66 61 75 6C ...     33              DC.B    'Default order: descending',$A,$D
000011A2= 53 4F 52 54 57 20 ...     34              DC.B    'SORTW <address1> <address2>[ A|D] eg: SORTW $2000 $201E A<CR>',$A,$A,$D
000011E2= 4D 4D 3A 20 4D 6F ...     35              DC.B    'MM: Modifies Data In Memory',$A,$D
000011FF= 44 65 66 61 75 6C ...     36              DC.B    'Default: Displays one byte',$A,$D
0000121B= 57 3A 20 44 69 73 ...     37              DC.B    'W: Displays one word',$A,$D
00001231= 4C 3A 20 44 69 73 ...     38              DC.B    'L: Displays one long word',$A,$D
0000124C= 4D 4D 20 3C 61 64 ...     39              DC.B    'MM <address>[ size]',$A,$A,$D
00001262                            40              ** Add all others as I go
00001262= 45 58 49 54 3A 20 ...     41              DC.B    'EXIT: Exit the monitor program eg: EXIT<CR>',0
0000128E                            42              
0000128E                            43  *** RUNNING PROGRAM ***
0000128E                            44      ;ORG     $1200 --> allow for as much as necessary before this, and add program right after it
0000128E                            45  START:                  ; first instruction of program
0000128E                            46  
0000128E  =00000050                 47  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
0000128E  =00003000                 48  STACK       EQU $3000
0000128E  4FF8 3000                 49          LEA     STACK,A7
00001292  48E7 FFFE                 50          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to display them
00001296                            51  
00001296                            52          **Populate exception vector table
00001296                            53          
00001296                            54  *** MAIN: Prompt, execute and repeat ***
00001296  43F8 1000                 55          LEA     WELCOME,A1
0000129A  103C 000D                 56          MOVE.B  #13,D0
0000129E  4E4F                      57          TRAP    #15     ; display welcome message
000012A0  43F8 102C                 58  PROMPT  LEA     PROMPT_STR,A1  
000012A4  103C 000E                 59          MOVE.B  #14,D0
000012A8  4E4F                      60          TRAP    #15     ; print out prompt
000012AA  9FFC 00000050             61          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input
000012B0  224F                      62          MOVEA.L A7,A1   ; input will go in stack
000012B2  103C 0002                 63          MOVE.B  #2,D0
000012B6  4E4F                      64          TRAP    #15     ; read user input, length stored in D1
000012B8                            65          
000012B8  49F8 1067                 66          LEA     COM_TABL,A4 ; beginning of command table
000012BC  4BF8 1084                 67          LEA     COM_ADDR,A5 ; end of command table
000012C0  4283                      68          CLR.L   D3      ; will be the count of where the command is
000012C2  4282                      69  SEARCH  CLR.L   D2
000012C4  141C                      70          MOVE.B  (A4)+,D2   ; length of next command string
000012C6  0402 0030                 71          SUBI.B  #$30,D2 ; convert ascii num to hex
000012CA  2C49                      72          MOVEA.L A1,A6   ; pointer to input string
000012CC  BD0C                      73  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
000012CE  56CA FFFC                 74          DBNE    D2,CMP_B    ; keep comparing characters until length is over
000012D2  4A42                      75          TST.W   D2
000012D4  6D00 0012                 76          BLT     EXEC    ; loop was exhausted and all chars were equal
000012D8  D9C2                      77          ADDA.L  D2,A4   ; go to end of command
000012DA  5483                      78          ADDQ.L  #2,D3   ; else, increment offset by word size
000012DC  BBCC                      79          CMPA.L  A4,A5 ; end of COM_TABL
000012DE  6CE2                      80          BGE     SEARCH  ; keep on searching
000012E0                            81          
000012E0  6100 0140                 82          BSR     INVALID ; print invalid command message
000012E4  6000 000E                 83          BRA     ENDLOOP ; prompt again
000012E8                            84          
000012E8  DBC3                      85  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
000012EA  267C 00000000             86          MOVEA.L #0,A3   ; clear A3, used for subroutine call
000012F0  3655                      87          MOVEA.W (A5),A3 ; move that command's address to register
000012F2  4E93                      88          JSR     (A3)    ; jump to that command's subroutine (below)
000012F4                            89  
000012F4  DFFC 00000050             90  ENDLOOP ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input
000012FA  60A4                      91          BRA     PROMPT  ; prompt again
000012FC                            92  
000012FC                            93  *** DEBUGGING COMMANDS ***
000012FC                            94  * HELP -- displays help message
000012FC  48E7 8040                 95  HELP    MOVEM.L D0/A1,-(A7) ; store used registers in stack
00001300  43F8 108E                 96          LEA     HELP_MSG,A1  
00001304  103C 000D                 97          MOVE.B  #13,D0
00001308  4E4F                      98          TRAP    #15     ; print help message
0000130A  4CDF 0201                 99          MOVEM.L (A7)+,D0/A1 ; restore registers from stack
0000130E  4E75                     100          RTS
00001310                           101          
00001310                           102  * For this subroutine and others, A6 contains the start of the command's parameters
00001310                           103  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
00001310                           104  
00001310                           105  * MDSP -- displays memory block
00001310  48E7 F070                106  MDSP    MOVEM.L D0-D3/A1-A3,-(A7)
00001314  121E                     107          MOVE.B  (A6)+,D1    ; first '$'
00001316  0C01 0024                108          CMPI.B  #$24,D1 ; is it '$'?
0000131A  6600 006C                109          BNE     MDSPINV ; wrong command usage
0000131E  6100 0116                110          BSR     MEM2HEX ; D1 has 1st address in hex
00001322  2441                     111          MOVEA.L D1,A2   ;store in A2
00001324  121E                     112          MOVE.B  (A6)+,D1    ; space in between addresses
00001326  4A01                     113          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
00001328  6600 000E                114          BNE     MDSPADDR2
0000132C  264A                     115          MOVEA.L A2,A3
0000132E  D7FC 00000010            116          ADDA.L  #16,A3  ; A3 = A2 +16
00001334  6000 0012                117          BRA     MDSPLOOP
00001338  121E                     118  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
0000133A  0C01 0024                119          CMPI.B  #$24,D1
0000133E  6600 0048                120          BNE     MDSPINV
00001342  6100 00F2                121          BSR     MEM2HEX ; D1 has 2nd address in hex
00001346  2641                     122          MOVEA.L D1,A3
00001348  224F                     123  MDSPLOOP    MOVEA.L A7,A1
0000134A  93FC 00000040            124          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
00001350  133C 0000                125          MOVE.B  #$00,-(A1) ; null terminator
00001354  133C 0020                126          MOVE.B  #$20,-(A1)  ; space
00001358  133C 003E                127          MOVE.B  #$3E,-(A1)  ; '<' for nicer output
0000135C  220A                     128          MOVE.L  A2,D1
0000135E  6100 0112                129          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
00001362  133C 0024                130          MOVE.B  #$24,-(A1)  ; '$' for nicer output
00001366  103C 000E                131          MOVE.B  #14,D0
0000136A  4E4F                     132          TRAP    #15     ; print current memory address
0000136C  133C 0000                133          MOVE.B  #$00,-(A1) ; null terminator
00001370  133C 0020                134          MOVE.B  #$20,-(A1)  ; space
00001374  221A                     135          MOVE.L  (A2)+,D1
00001376  6100 00FA                136          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
0000137A  103C 000D                137          MOVE.B  #13,D0
0000137E  4E4F                     138          TRAP    #15
00001380  B7CA                     139          CMPA.L  A2,A3
00001382  6EC4                     140          BGT     MDSPLOOP
00001384  6000 0006                141          BRA     MDSPDONE
00001388  6100 0098                142  MDSPINV BSR     INVALID ; print invalid command message
0000138C  4CDF 0E0F                143  MDSPDONE    MOVEM.L (A7)+,D0-D3/A1-A3
00001390  4E75                     144          RTS
00001392                           145  
00001392                           146  * SORTW -- implements bubble sort (unsigned numbers)
00001392  48E7 F878                147  SORTW   MOVEM.L D0-D4/A1-A4,-(A7)
00001396  121E                     148          MOVE.B  (A6)+,D1    ; first '$'
00001398  0C01 0024                149          CMPI.B  #$24,D1     ; is it '$'?
0000139C  6600 0072                150          BNE     SORTWINV    ; wrong command usage
000013A0  6100 0094                151          BSR     MEM2HEX     ; D1 has 1st address in hex
000013A4  2441                     152          MOVEA.L D1,A2       ; store in A2
000013A6  121E                     153          MOVE.B  (A6)+,D1    ; space in between addresses
000013A8  0C01 0020                154          CMPI.B  #$20,D1     ; is it ' '?
000013AC  6600 0062                155          BNE     SORTWINV    ; wrong command usage
000013B0  121E                     156          MOVE.B  (A6)+,D1    ; second '$'
000013B2  0C01 0024                157          CMPI.B  #$24,D1     ; is it '$'?
000013B6  6600 0058                158          BNE     SORTWINV    ; wrong command usage
000013BA  6100 007A                159          BSR     MEM2HEX     ; D1 has now the 2nd address
000013BE  2641                     160          MOVEA.L D1,A3       ; store in A3
000013C0  121E                     161          MOVE.B  (A6)+,D1    ; space 
000013C2  0C01 0000                162          CMPI.B  #$00,D1     ; is it NULL?
000013C6  6700 001C                163          BEQ     SORTWDEF    ; use default: descending (D1=0)
000013CA  0C01 0020                164          CMPI.B  #$20,D1     ; or is it ' '?
000013CE  6600 0040                165          BNE     SORTWINV    ; wrong command usage
000013D2  121E                     166          MOVE.B  (A6)+,D1    ; char either 'A' or 'D'
000013D4  0C01 0041                167          CMPI.B  #$41,D1     ; is it 'A'?
000013D8  6700 000C                168          BEQ     SORTWLOOP   ; if so, D1 marks ascending
000013DC  0C01 0044                169          CMPI.B  #$44,D1     ; else, is it 'D'?
000013E0  6600 002E                170          BNE     SORTWINV    ; if it isn't, input was invalid
000013E4  4281                     171  SORTWDEF    CLR.L   D1          ; if it is, D1=0 marks descending
000013E6  284A                     172  SORTWLOOP   MOVEA.L A2,A4   ; first address copied into A4
000013E8  4A01                     173  SORTWCMP    TST.B   D1      ; tells us whether ascending or descending
000013EA  6700 000C                174          BEQ     SORTWD  ; do descending
000013EE  B94C                     175  SORTWA  CMP.W   (A4)+,(A4)+ ; compare next two numbers
000013F0  6500 0016                176          BCS     SORTWSWAP   ; swap if not in ascending order (if 1st>2nd)
000013F4  6000 0008                177          BRA     SORTWNEXT   ; otherwise, move on
000013F8  B94C                     178  SORTWD  CMP.W   (A4)+,(A4)+ ; compare next two numbers
000013FA  6200 000C                179          BHI     SORTWSWAP   ; swap if not in descending order (if 2nd>1st)
000013FE  558C                     180  SORTWNEXT   SUBQ.L  #2,A4   ; look back at previous number
00001400  B7CC                     181          CMP.L   A4,A3       
00001402  66E4                     182          BNE     SORTWCMP    ; keep comparing if not at end yet (A3 inclusive)
00001404  6000 000E                183          BRA     SORTWDONE   ; else, done
00001408  2824                     184  SORTWSWAP MOVE.L  -(A4),D4   ; move both words to register
0000140A  4844                     185          SWAP.W  D4  ; swap the two words 
0000140C  2884                     186          MOVE.L  D4,(A4) ; write them back
0000140E  60D6                     187          BRA     SORTWLOOP   ; loop again from start
00001410  6100 0010                188  SORTWINV    BSR INVALID
00001414  4CDF 1E1F                189  SORTWDONE   MOVEM.L (A7)+,D0-D4/A1-A4
00001418  4E75                     190          RTS
0000141A                           191  
0000141A                           192  * MM -- 
0000141A                           193  MM    
0000141A  4E75                     194          RTS
0000141C                           195  
0000141C                           196  * EXIT -- terminates the program
0000141C  103C 0009                197  EXIT    MOVE.B  #9, D0
00001420  4E4F                     198          TRAP    #15     ; exit program
00001422                           199  
00001422                           200  *** HELPERS ***
00001422                           201  * Print INVALID message:
00001422  48E7 8040                202  INVALID MOVEM.L D0/A1,-(A7)
00001426  43F8 103A                203          LEA     INVALID_MSG,A1  ; command was invalid
0000142A  103C 000D                204          MOVE.B  #13,D0
0000142E  4E4F                     205          TRAP    #15     ; output invalid command
00001430  4CDF 0201                206          MOVEM.L (A7)+,D0/A1
00001434  4E75                     207          RTS
00001436                           208  
00001436                           209  * Takes X digits from (A6) in ascii and puts them in D1 as hex:
00001436  48E7 8100                210  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
0000143A  4281                     211          CLR.L   D1
0000143C  1E1E                     212          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000143E  0C07 0030                213          CMPI.B  #$30,D7
00001442  6D00 0016                214          BLT     MEM2HEXDONE ; reached some whitespace or non-numeric ascii
00001446  6100 001A                215  M2HNEXT BSR     BYTE2HEX    ; byte to hex digit, in D7
0000144A  D207                     216          ADD.B   D7,D1
0000144C  1E1E                     217          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000144E  0C07 0030                218          CMPI.B  #$30,D7
00001452  6D00 0006                219          BLT     MEM2HEXDONE ; reached some whitespace or non-numeric ascii
00001456  E981                     220          ASL.L   #4,D1   ; skip this the last time
00001458  60EC                     221          BRA     M2HNEXT ; loop again because not done
0000145A  538E                     222  MEM2HEXDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
0000145C  4CDF 0081                223          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001460  4E75                     224          RTS
00001462                           225  
00001462                           226  * Takes byte in ascii in D7 and converts it to hex in D7:
00001462                           227  * Assumes 0-9 or A-F
00001462  0C07 0040                228  BYTE2HEX CMPI.B #$40,D7
00001466  6D00 0004                229          BLT B2HSKIPPY
0000146A  5F07                     230          SUBQ.B  #$7,D7   ; only for A-F
0000146C  0407 0030                231  B2HSKIPPY   SUB.B   #$30,D7
00001470  4E75                     232          RTS
00001472                           233          
00001472                           234  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001472  48E7 A100                235  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001476  4280                     236          CLR.L   D0   ; counter
00001478  2E01                     237  H2MNEXT MOVE.L  D1,D7
0000147A  2400                     238          MOVE.L D0,D2
0000147C  5342                     239  H2MRIGHT    SUBQ.W  #1,D2
0000147E  6D00 0006                240          BLT     H2MDONE
00001482  E88F                     241          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001484  60F6                     242          BRA     H2MRIGHT
00001486  6100 0012                243  H2MDONE BSR     HEX2BYTE ; convert to ascii in D7
0000148A  1307                     244          MOVE.B  D7,-(A1)
0000148C  5240                     245          ADDQ.W  #1,D0
0000148E  0C40 0008                246          CMPI.W  #8,D0
00001492  6DE4                     247          BLT     H2MNEXT
00001494  4CDF 0085                248          MOVEM.L (A7)+,D0/D2/D7
00001498  4E75                     249          RTS
0000149A                           250  
0000149A                           251  * Takes hex digit in D7 and converts it to ascii byte in D7:
0000149A                           252  * Assumes 0-9 or A-F
0000149A  CEBC 0000000F            253  HEX2BYTE AND.L  #$0F,D7 ; mask and take only smallest hex digit
000014A0  0C07 000A                254          CMPI.B  #$A,D7
000014A4  6D00 0004                255          BLT H2BSKIPPY
000014A8  5E07                     256          ADDQ.B  #$7,D7   ; only for A-F
000014AA  0607 0030                257  H2BSKIPPY   ADD.B   #$30,D7
000014AE  4E75                     258          RTS
000014B0                           259  
000014B0                           260      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B2HSKIPPY           146C
BYTE2HEX            1462
CMP_B               12CC
COM_ADDR            1084
COM_TABL            1067
ENDLOOP             12F4
EXEC                12E8
EXIT                141C
H2BSKIPPY           14AA
H2MDONE             1486
H2MNEXT             1478
H2MRIGHT            147C
HELP                12FC
HELP_MSG            108E
HEX2BYTE            149A
HEX2MEM             1472
INVALID             1422
INVALID_MSG         103A
M2HNEXT             1446
MAX_IN_LEN          50
MDSP                1310
MDSPADDR2           1338
MDSPDONE            138C
MDSPINV             1388
MDSPLOOP            1348
MEM2HEX             1436
MEM2HEXDONE         145A
MM                  141A
PROMPT              12A0
PROMPT_STR          102C
SEARCH              12C2
SORTW               1392
SORTWA              13EE
SORTWCMP            13E8
SORTWD              13F8
SORTWDEF            13E4
SORTWDONE           1414
SORTWINV            1410
SORTWLOOP           13E6
SORTWNEXT           13FE
SORTWSWAP           1408
STACK               3000
START               128E
WELCOME             1000

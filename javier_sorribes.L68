0000140C Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.29
Created On: 4/19/2017 8:59:51 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 0A 0D 4D 4F 4E 49 ...     11  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
0000103A= 49 4E 56 41 4C 49 ...     12  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
0000104B= 54 79 70 65 20 48 ...     13              DC.B    'Type HELP for command usage',0
00001067                            14  
00001067= 34 48 45 4C 50 00         15  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000106D= 34 4D 44 53 50 20         16              DC.B    '4MDSP',$20  ; number specifies length of word 
00001073= 35 53 4F 52 54 57 20      17              DC.B    '5SORTW',$20    ; used for SEARCH (not input)
0000107A= 32 4D 4D 00               18              DC.B    '2MM',0
0000107E= 32 44 46 00               19              DC.B    '2DF',0
00001082= 34 45 58 49 54 00         20              DC.B    '4EXIT',0
00001088= 34 43 4F 4E 56 20         21              DC.B    '4CONV',$20
0000108E                            22              
0000108E= 147E                      23  COM_ADDR    DC.W    HELP        ; Command addresses table
00001090= 1492                      24              DC.W    MDSP
00001092= 152C                      25              DC.W    SORTW
00001094= 15B4                      26              DC.W    MM
00001096= 15B6                      27              DC.W    DF
00001098= 15E6                      28              DC.W    EXIT
0000109A= 15FA                      29              DC.W    CONV
0000109C                            30              
0000109C= 48 45 4C 50 3A 20 ...     31  HELP_MSG    DC.B    'HELP: Displays This Message',$A,$A,$D
000010BA= 4D 44 53 50 3A 20 ...     32              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
000010E5= 44 65 66 61 75 6C ...     33              DC.B    'Default address2: address1 + 16',$A,$D
00001106= 4D 44 53 50 20 3C ...     34              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
0000113C= 53 4F 52 54 57 3A ...     35              DC.B    'SORTW: Sorts Unsigned Words In A Memory Block',$A,$D
0000116B= 42 6F 74 68 20 61 ...     36              DC.B    'Both address1 and address2 are inclusive',$A,$D
00001195= 44 65 66 61 75 6C ...     37              DC.B    'Default order: descending',$A,$D
000011B0= 53 4F 52 54 57 20 ...     38              DC.B    'SORTW <address1> <address2>[ A|D] eg: SORTW $2000 $201E A<CR>',$A,$A,$D
000011F0= 4D 4D 3A 20 4D 6F ...     39              DC.B    'MM: Modifies Data In Memory',$A,$D
0000120D= 44 65 66 61 75 6C ...     40              DC.B    'Default: Displays one byte',$A,$D
00001229= 57 3A 20 44 69 73 ...     41              DC.B    'W: Displays one word',$A,$D
0000123F= 4C 3A 20 44 69 73 ...     42              DC.B    'L: Displays one long word',$A,$D
0000125A= 4D 4D 20 3C 61 64 ...     43              DC.B    'MM <address>[ size]',$A,$A,$D
00001270                            44              ** Add all others as I go
00001270= 44 46 3A 20 44 69 ...     45              DC.B    'DF: Displays All Formatted Registers eg: DF<CR>',$A,$A,$D
000012A2= 45 58 49 54 3A 20 ...     46              DC.B    'EXIT: Exit The Monitor Program eg: EXIT<CR>',$A,$A,$D
000012D0= 43 4F 4E 56 3A 20 ...     47              DC.B    'CONV: Convert Hex to Decimal, Or Vice Versa',$A,$D
000012FD= 43 4F 4E 56 20 5B ...     48              DC.B    'CONV [$]num eg: CONV 16<CR> returns $10',0
00001325                            49              
00001325= 0D 00                     50  DF_MSG      DC.B    $D,0    ; erase whatever had been printed on that line
00001327= 44 30 3D 00 58 58 ...     51              DC.B    'D0=',0,'XXXXXXXX',0,' D1=',0,'XXXXXXXX',0,' D2=',0,'XXXXXXXX',0,' D3=',0,'XXXXXXXX',$A,$D,0
00001360= 44 34 3D 00 58 58 ...     52              DC.B    'D4=',0,'XXXXXXXX',0,' D5=',0,'XXXXXXXX',0,' D6=',0,'XXXXXXXX',0,' D7=',0,'XXXXXXXX',$A,$D,0
00001399= 41 30 3D 00 58 58 ...     53              DC.B    'A0=',0,'XXXXXXXX',0,' A1=',0,'XXXXXXXX',0,' A2=',0,'XXXXXXXX',0,' A3=',0,'XXXXXXXX',$A,$D,0
000013D2= 41 34 3D 00 58 58 ...     54              DC.B    'A4=',0,'XXXXXXXX',0,' A5=',0,'XXXXXXXX',0,' A6=',0,'XXXXXXXX',0,' A7=',0,'XXXXXXXX',$A,$D,0
0000140B                            55              
0000140B                            56  *** RUNNING PROGRAM ***
0000140B                            57      ;ORG     $1200 --> allow for as much as necessary before this, and add program right after it
0000140B                            58  START:                  ; first instruction of program
0000140B                            59  
0000140B  =00000050                 60  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
0000140B  =00002FFC                 61  STACK       EQU $2FFC   ; $3000 minus a long word because A7 will be stored first
0000140C  21CF 2FFC                 62          MOVE.L  A7,STACK    ; store original location of stack beforehand
00001410  4FF8 2FFC                 63          LEA     STACK,A7
00001414  48E7 FFFE                 64          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to restore them
00001418                            65  
00001418                            66  ** Populate exception vector table ***
00001418  21FC 00001714 0008        67          MOVE.L  #BERR,$8
00001420                            68          
00001420                            69  *** MAIN: Prompt, execute and repeat ***
00001420  43F8 1000                 70          LEA     WELCOME,A1
00001424  103C 000D                 71          MOVE.B  #13,D0
00001428  4E4F                      72          TRAP    #15     ; display welcome message
0000142A  9FFC 00000050             73          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input (do only once)
00001430  43F8 102C                 74  PROMPT  LEA     PROMPT_STR,A1  
00001434  103C 000E                 75          MOVE.B  #14,D0
00001438  4E4F                      76          TRAP    #15     ; print out prompt
0000143A  224F                      77          MOVEA.L A7,A1   ; input will go in stack
0000143C  103C 0002                 78          MOVE.B  #2,D0
00001440  4E4F                      79          TRAP    #15     ; read user input, length stored in D1
00001442                            80          
00001442  49F8 1067                 81          LEA     COM_TABL,A4 ; beginning of command table
00001446  4BF8 108E                 82          LEA     COM_ADDR,A5 ; end of command table
0000144A  4283                      83          CLR.L   D3      ; will be the count of where the command is
0000144C  4282                      84  SEARCH  CLR.L   D2
0000144E  141C                      85          MOVE.B  (A4)+,D2   ; length of next command string
00001450  0402 0030                 86          SUBI.B  #$30,D2 ; convert ascii num to hex
00001454  2C49                      87          MOVEA.L A1,A6   ; pointer to input string
00001456  BD0C                      88  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
00001458  56CA FFFC                 89          DBNE    D2,CMP_B    ; keep comparing characters until length is over
0000145C  4A42                      90          TST.W   D2
0000145E  6D00 0010                 91          BLT     EXEC    ; loop was exhausted and all chars were equal
00001462  D9C2                      92          ADDA.L  D2,A4   ; go to end of command
00001464  5483                      93          ADDQ.L  #2,D3   ; else, increment offset by word size
00001466  BBCC                      94          CMPA.L  A4,A5 ; end of COM_TABL
00001468  6CE2                      95          BGE     SEARCH  ; keep on searching
0000146A                            96          
0000146A  6100 01C6                 97          BSR     INVALID ; print invalid command message
0000146E  60C0                      98          BRA     PROMPT ; prompt again
00001470                            99          
00001470  DBC3                     100  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
00001472  267C 00000000            101          MOVEA.L #0,A3   ; clear A3, used for subroutine call
00001478  3655                     102          MOVEA.W (A5),A3 ; move that command's address to register
0000147A  4E93                     103          JSR     (A3)    ; jump to that command's subroutine (below)
0000147C                           104  
0000147C  60B2                     105          BRA     PROMPT  ; prompt again
0000147E                           106  
0000147E                           107  *** DEBUGGING COMMANDS ***
0000147E                           108  * HELP -- displays help message
0000147E  48E7 8040                109  HELP    MOVEM.L D0/A1,-(A7) ; store used registers in stack
00001482  43F8 109C                110          LEA     HELP_MSG,A1  
00001486  103C 000D                111          MOVE.B  #13,D0
0000148A  4E4F                     112          TRAP    #15     ; print help message
0000148C  4CDF 0201                113          MOVEM.L (A7)+,D0/A1 ; restore registers from stack
00001490  4E75                     114          RTS
00001492                           115          
00001492                           116  * For this subroutine and others, A6 contains the start of the command's parameters
00001492                           117  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
00001492                           118  
00001492                           119  * MDSP -- displays memory block
00001492  48E7 F878                120  MDSP    MOVEM.L D0-D4/A1-A4,-(A7)
00001496  121E                     121          MOVE.B  (A6)+,D1    ; first '$'
00001498  0C01 0024                122          CMPI.B  #$24,D1 ; is it '$'?
0000149C  6600 0084                123          BNE     MDSPINV ; wrong command usage
000014A0  6100 01A4                124          BSR     MEM2HEX ; D1 has 1st address in hex
000014A4  2441                     125          MOVEA.L D1,A2   ;store in A2
000014A6  121E                     126          MOVE.B  (A6)+,D1    ; space in between addresses
000014A8  4A01                     127          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
000014AA  6600 000E                128          BNE     MDSPADDR2
000014AE  264A                     129          MOVEA.L A2,A3
000014B0  D7FC 00000010            130          ADDA.L  #16,A3  ; A3 = A2 +16
000014B6  6000 0012                131          BRA     MDSPLOOP
000014BA  121E                     132  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
000014BC  0C01 0024                133          CMPI.B  #$24,D1
000014C0  6600 0060                134          BNE     MDSPINV
000014C4  6100 0180                135          BSR     MEM2HEX ; D1 has 2nd address in hex
000014C8  2641                     136          MOVEA.L D1,A3
000014CA  224F                     137  MDSPLOOP    MOVEA.L A7,A1
000014CC  93FC 00000040            138          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
000014D2  133C 0000                139          MOVE.B  #$00,-(A1) ; null terminator
000014D6  133C 0020                140          MOVE.B  #$20,-(A1)  ; space
000014DA  133C 003E                141          MOVE.B  #$3E,-(A1)  ; '<' for nicer output
000014DE  220A                     142          MOVE.L  A2,D1
000014E0  6100 01A0                143          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
000014E4  133C 0024                144          MOVE.B  #$24,-(A1)  ; '$' for nicer output
000014E8  103C 000E                145          MOVE.B  #14,D0
000014EC  4E4F                     146          TRAP    #15     ; print current memory address
000014EE  133C 0000                147          MOVE.B  #$00,-(A1) ; null terminator
000014F2  133C 0020                148          MOVE.B  #$20,-(A1)  ; space
000014F6  221A                     149          MOVE.L  (A2)+,D1
000014F8  2849                     150          MOVEA.L A1,A4   ; old value of A1
000014FA  6100 0186                151          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
000014FE  99C9                     152          SUBA.L  A1,A4   ; difference
00001500  280C                     153          MOVE.L  A4,D4   ; D4 counter to add trailing zeros
00001502  B8BC 00000008            154  MDSPZEROS CMP.L   #8,D4
00001508  6C00 000A                155          BGE     MDSPPRINT
0000150C  133C 0030                156          MOVE.B  #$30,-(A1)
00001510  5284                     157          ADDQ.L  #1,D4
00001512  60EE                     158          BRA     MDSPZEROS
00001514  103C 000D                159  MDSPPRINT   MOVE.B  #13,D0
00001518  4E4F                     160          TRAP    #15
0000151A  B7CA                     161          CMPA.L  A2,A3
0000151C  6EAC                     162          BGT     MDSPLOOP
0000151E  6000 0006                163          BRA     MDSPDONE
00001522  6100 010E                164  MDSPINV BSR     INVALID ; print invalid command message
00001526  4CDF 1E1F                165  MDSPDONE    MOVEM.L (A7)+,D0-D4/A1-A4
0000152A  4E75                     166          RTS
0000152C                           167  
0000152C                           168  * SORTW -- implements bubble sort (unsigned numbers)
0000152C  48E7 F878                169  SORTW   MOVEM.L D0-D4/A1-A4,-(A7)
00001530  121E                     170          MOVE.B  (A6)+,D1    ; first '$'
00001532  0C01 0024                171          CMPI.B  #$24,D1     ; is it '$'?
00001536  6600 0072                172          BNE     SORTWINV    ; wrong command usage
0000153A  6100 010A                173          BSR     MEM2HEX     ; D1 has 1st address in hex
0000153E  2441                     174          MOVEA.L D1,A2       ; store in A2
00001540  121E                     175          MOVE.B  (A6)+,D1    ; space in between addresses
00001542  0C01 0020                176          CMPI.B  #$20,D1     ; is it ' '?
00001546  6600 0062                177          BNE     SORTWINV    ; wrong command usage
0000154A  121E                     178          MOVE.B  (A6)+,D1    ; second '$'
0000154C  0C01 0024                179          CMPI.B  #$24,D1     ; is it '$'?
00001550  6600 0058                180          BNE     SORTWINV    ; wrong command usage
00001554  6100 00F0                181          BSR     MEM2HEX     ; D1 has now the 2nd address
00001558  2641                     182          MOVEA.L D1,A3       ; store in A3
0000155A  121E                     183          MOVE.B  (A6)+,D1    ; space 
0000155C  0C01 0000                184          CMPI.B  #$00,D1     ; is it NULL?
00001560  6700 001C                185          BEQ     SORTWDEF    ; use default: descending (D1=0)
00001564  0C01 0020                186          CMPI.B  #$20,D1     ; or is it ' '?
00001568  6600 0040                187          BNE     SORTWINV    ; wrong command usage
0000156C  121E                     188          MOVE.B  (A6)+,D1    ; char either 'A' or 'D'
0000156E  0C01 0041                189          CMPI.B  #$41,D1     ; is it 'A'?
00001572  6700 000C                190          BEQ     SORTWLOOP   ; if so, D1 marks ascending
00001576  0C01 0044                191          CMPI.B  #$44,D1     ; else, is it 'D'?
0000157A  6600 002E                192          BNE     SORTWINV    ; if it isn't, input was invalid
0000157E  4281                     193  SORTWDEF    CLR.L   D1          ; if it is, D1=0 marks descending
00001580  284A                     194  SORTWLOOP   MOVEA.L A2,A4   ; first address copied into A4
00001582  4A01                     195  SORTWCMP    TST.B   D1      ; tells us whether ascending or descending
00001584  6700 000C                196          BEQ     SORTWD  ; do descending
00001588  B94C                     197  SORTWA  CMP.W   (A4)+,(A4)+ ; compare next two numbers
0000158A  6500 0016                198          BCS     SORTWSWAP   ; swap if not in ascending order (if 1st>2nd)
0000158E  6000 0008                199          BRA     SORTWNEXT   ; otherwise, move on
00001592  B94C                     200  SORTWD  CMP.W   (A4)+,(A4)+ ; compare next two numbers
00001594  6200 000C                201          BHI     SORTWSWAP   ; swap if not in descending order (if 2nd>1st)
00001598  558C                     202  SORTWNEXT   SUBQ.L  #2,A4   ; look back at previous number
0000159A  B7CC                     203          CMP.L   A4,A3       
0000159C  66E4                     204          BNE     SORTWCMP    ; keep comparing if not at end yet (A3 inclusive)
0000159E  6000 000E                205          BRA     SORTWDONE   ; else, done
000015A2  2824                     206  SORTWSWAP MOVE.L  -(A4),D4   ; move both words to register
000015A4  4844                     207          SWAP.W  D4  ; swap the two words 
000015A6  2884                     208          MOVE.L  D4,(A4) ; write them back
000015A8  60D6                     209          BRA     SORTWLOOP   ; loop again from start
000015AA  6100 0086                210  SORTWINV    BSR INVALID
000015AE  4CDF 1E1F                211  SORTWDONE   MOVEM.L (A7)+,D0-D4/A1-A4
000015B2  4E75                     212          RTS
000015B4                           213  
000015B4                           214  * MM -- 
000015B4                           215  MM    
000015B4  4E75                     216          RTS
000015B6                           217          
000015B6                           218  * DF -- displays formatted registers
000015B6  48E7 C0C0                219  DF      MOVEM.L D0-D1/A0-A1,-(A7)
000015BA  41F8 2FFC                220          LEA     STACK,A0
000015BE  91FC 00000078            221          SUBA.L  #120,A0
000015C4  91FC 00000050            222          SUBA.L  #MAX_IN_LEN,A0
000015CA  43F8 1325                223          LEA     DF_MSG,A1
000015CE  303C 000E                224          MOVE    #14,D0
000015D2  4E4F                     225          TRAP    #15     ; print carriage return
000015D4  720F                     226          MOVE.L  #15,D1  ; number of registers - 1 to print
000015D6  4E4F                     227  DFLOOP  TRAP    #15     ; print register name
000015D8  2258                     228          MOVE.L  (A0)+,A1    ; put register value in A1
000015DA  4E4F                     229          TRAP    #15     ; print register value
000015DC  50C9 FFF8                230          DBT     D1,DFLOOP
000015E0  4CDF 0303                231          MOVEM.L (A7)+,D0-D1/A0-A1
000015E4  4E75                     232          RTS
000015E6                           233  
000015E6                           234  * EXIT -- terminates the program
000015E6  588F                     235  EXIT    ADDA.L  #4,A7   ; move past the PC stored in the stack
000015E8  DFFC 00000050            236          ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input
000015EE  4CDF 7FFF                237          MOVEM.L (A7)+,D0-D7/A0-A6   ; restore all registers in stack
000015F2  2E78 2FFC                238          MOVEA.L STACK,A7
000015F6  6000 0138                239          BRA     END     ; exit program
000015FA                           240          
000015FA                           241  * The 2 extra commands:
000015FA                           242  * CONV -- takes in hex and returns decimal, or viceversa
000015FA  48E7 C040                243  CONV    MOVEM.L D0-D1/A1,-(A7)
000015FE  121E                     244          MOVE.B  (A6)+,D1
00001600  0C01 0024                245          CMPI.B  #$24,D1 ; is it '$'?
00001604  6700 0016                246          BEQ     CONVH2D ; if so, hex to dec
00001608  538E                     247  CONVD2H SUBQ.L  #1,A6   ; point back at first number
0000160A  6100 00BA                248          BSR     MEM2DEC ; D1 contains the decimal number
0000160E  224E                     249          MOVEA.L A6,A1   ; number ready to print
00001610  6100 0070                250          BSR     HEX2MEM ; that number is written as hex in memory
00001614  133C 0024                251          MOVE.B  #'$',-(A1)
00001618  6000 000C                252          BRA     CONVDONE
0000161C  6100 0028                253  CONVH2D BSR     MEM2HEX ; convert ascii to hex
00001620  224E                     254          MOVEA.L A6,A1   ;number ready to print
00001622  6100 00CE                255          BSR     DEC2MEM ; convert it back to ascii but as decimal
00001626  103C 000D                256  CONVDONE MOVE.B #13,D0
0000162A  4E4F                     257          TRAP    #15 ; print result
0000162C  4CDF 0203                258          MOVEM.L (A7)+,D0-D1/A1
00001630  4E75                     259          RTS
00001632                           260  
00001632                           261  *** HELPERS ***
00001632                           262  * Print INVALID message:
00001632  48E7 8040                263  INVALID MOVEM.L D0/A1,-(A7)
00001636  43F8 103A                264          LEA     INVALID_MSG,A1  ; command was invalid
0000163A  103C 000D                265          MOVE.B  #13,D0
0000163E  4E4F                     266          TRAP    #15     ; output invalid command
00001640  4CDF 0201                267          MOVEM.L (A7)+,D0/A1
00001644  4E75                     268          RTS
00001646                           269  
00001646                           270  * Takes X digits from (A6) in ascii and puts them in D1 as hex:
00001646  48E7 8100                271  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
0000164A  4281                     272          CLR.L   D1
0000164C  1E1E                     273          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000164E  0C07 0030                274          CMPI.B  #$30,D7
00001652  6D00 0016                275          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001656  6100 001A                276  M2HNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
0000165A  D207                     277          ADD.B   D7,D1
0000165C  1E1E                     278          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000165E  0C07 0030                279          CMPI.B  #$30,D7
00001662  6D00 0006                280          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001666  E981                     281          ASL.L   #4,D1   ; skip this the last time
00001668  60EC                     282          BRA     M2HNEXT ; loop again because not done
0000166A  538E                     283  M2HDONE SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
0000166C  4CDF 0081                284          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001670  4E75                     285          RTS
00001672                           286  
00001672                           287  * Takes byte in ascii in D7 and converts it to digit in D7:
00001672                           288  * Assumes 0-9 or A-F
00001672  0C07 0040                289  ASCII2NUM   CMPI.B #$40,D7
00001676  6D00 0004                290          BLT A2NSKIPPY
0000167A  5F07                     291          SUBQ.B  #$7,D7   ; only for A-F
0000167C  0407 0030                292  A2NSKIPPY   SUB.B   #$30,D7
00001680  4E75                     293          RTS
00001682                           294          
00001682                           295  * Takes digits from D1 in hex and puts them into -X(A1) in ascii (no trailing zeros):
00001682  48E7 A100                296  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001686  4280                     297          CLR.L   D0   ; counter
00001688  2E01                     298  H2MNEXT MOVE.L  D1,D7
0000168A  2400                     299          MOVE.L D0,D2
0000168C  5342                     300  H2MRIGHT    SUBQ.W  #1,D2
0000168E  6D00 0006                301          BLT     H2MDONE
00001692  E88F                     302          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001694  60F6                     303          BRA     H2MRIGHT
00001696  4A87                     304  H2MDONE TST.L   D7
00001698  6700 0010                305          BEQ     H2MEND      ; if number done
0000169C  6100 0012                306          BSR     NUM2ASCII   ; convert to ascii in D7
000016A0  1307                     307          MOVE.B  D7,-(A1)
000016A2  5240                     308          ADDQ.W  #1,D0
000016A4  0C40 0008                309          CMPI.W  #8,D0
000016A8  6DDE                     310          BLT     H2MNEXT
000016AA  4CDF 0085                311  H2MEND  MOVEM.L (A7)+,D0/D2/D7
000016AE  4E75                     312          RTS
000016B0                           313  
000016B0                           314  * Takes digit in D7 and converts it to ascii byte in D7:
000016B0                           315  * Assumes 0-9 or A-F
000016B0  CEBC 0000000F            316  NUM2ASCII   AND.L  #$0F,D7 ; mask and take only smallest hex digit
000016B6  0C07 000A                317          CMPI.B  #$A,D7
000016BA  6D00 0004                318          BLT N2ASKIPPY
000016BE  5E07                     319          ADDQ.B  #$7,D7   ; only for A-F
000016C0  0607 0030                320  N2ASKIPPY   ADD.B   #$30,D7
000016C4  4E75                     321          RTS
000016C6                           322          
000016C6                           323  * Takes X digits from (A6) in ascii and puts them in D1 as dec:
000016C6  48E7 8100                324  MEM2DEC MOVEM.L D0/D7,-(A7)    ; store in stack
000016CA  4281                     325          CLR.L   D1
000016CC  1E1E                     326          MOVE.B (A6)+,D7    ; read in next byte (prime read)
000016CE  0C07 0030                327          CMPI.B  #$30,D7
000016D2  6D00 0016                328          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
000016D6  619A                     329  M2DNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
000016D8  D207                     330          ADD.B   D7,D1
000016DA  1E1E                     331          MOVE.B (A6)+,D7    ; read in next byte (prime read)
000016DC  0C07 0030                332          CMPI.B  #$30,D7
000016E0  6D00 0008                333          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
000016E4  C2FC 000A                334          MULU    #10,D1   ; skip this the last time
000016E8  60EC                     335          BRA     M2DNEXT ; loop again because not done
000016EA  538E                     336  M2DDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
000016EC  4CDF 0081                337          MOVEM.L (A7)+,D0/D7    ; restore from stack
000016F0  4E75                     338          RTS
000016F2                           339  
000016F2                           340  * Takes number from D1 in dec and puts them into -X(A1) in ascii:
000016F2  48E7 2100                341  DEC2MEM MOVEM.L D2/D7,-(A7)    ; store in stack
000016F6  2401                     342          MOVE.L  D1,D2
000016F8  84FC 000A                343  D2MLOOP DIVU    #10,D2
000016FC  2E02                     344          MOVE.L  D2,D7
000016FE  4847                     345          SWAP.W  D7
00001700  61AE                     346          BSR     NUM2ASCII
00001702  1307                     347          MOVE.B  D7,-(A1)
00001704  C4BC 0000FFFF            348          AND.L   #$0000FFFF,D2 ; make sure we use only word in next divisions
0000170A  4A42                     349          TST.W   D2
0000170C  66EA                     350          BNE     D2MLOOP
0000170E  4CDF 0084                351          MOVEM.L (A7)+,D2/D7
00001712  4E75                     352          RTS
00001714                           353          
00001714                           354  *** EXCEPTION HANDLERS ***
00001714  6100 FF1C                355  BERR    BSR     INVALID
00001718  6100 FF18                356          BSR     INVALID
0000171C  4FF8 2FFC                357          LEA     STACK,A7
00001720  9FFC 00000078            358          SUBA.L  #120,A7
00001726  9FFC 00000050            359          SUBA.L  #MAX_IN_LEN,A7
0000172C  6000 FD02                360          BRA     PROMPT
00001730                           361  
00001730                           362  END
Line 363 WARNING: Origin value is odd (Location counter set to next highest address)
00001730                           363      END     START        ; last line of source

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2NSKIPPY           167C
ASCII2NUM           1672
BERR                1714
CMP_B               1456
COM_ADDR            108E
COM_TABL            1067
CONV                15FA
CONVD2H             1608
CONVDONE            1626
CONVH2D             161C
D2MLOOP             16F8
DEC2MEM             16F2
DF                  15B6
DFLOOP              15D6
DF_MSG              1325
END                 1730
EXEC                1470
EXIT                15E6
H2MDONE             1696
H2MEND              16AA
H2MNEXT             1688
H2MRIGHT            168C
HELP                147E
HELP_MSG            109C
HEX2MEM             1682
INVALID             1632
INVALID_MSG         103A
M2DDONE             16EA
M2DNEXT             16D6
M2HDONE             166A
M2HNEXT             1656
MAX_IN_LEN          50
MDSP                1492
MDSPADDR2           14BA
MDSPDONE            1526
MDSPINV             1522
MDSPLOOP            14CA
MDSPPRINT           1514
MDSPZEROS           1502
MEM2DEC             16C6
MEM2HEX             1646
MM                  15B4
N2ASKIPPY           16C0
NUM2ASCII           16B0
PROMPT              1430
PROMPT_STR          102C
SEARCH              144C
SORTW               152C
SORTWA              1588
SORTWCMP            1582
SORTWD              1592
SORTWDEF            157E
SORTWDONE           15AE
SORTWINV            15AA
SORTWLOOP           1580
SORTWNEXT           1598
SORTWSWAP           15A2
STACK               2FFC
START               140B
WELCOME             1000

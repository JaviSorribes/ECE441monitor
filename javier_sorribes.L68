00001200 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/6/2017 00:22:18

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 0A 0D 4D 4F 4E 49 ...     11  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
0000103A= 49 4E 56 41 4C 49 ...     12  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
0000104B= 54 79 70 65 20 48 ...     13              DC.B    'Type HELP for command usage',0
00001067                            14  
00001067= 34 48 45 4C 50 00         15  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000106D= 34 4D 44 53 50 20         16              DC.B    '4MDSP',$20  ; number specifies length of word 
00001073= 32 4D 4D 00               17              DC.B    '2MM',0       ; used for SEARCH (not input)
00001077= 34 45 58 49 54 00         18              DC.B    '4EXIT',0
0000107D                            19              
0000107E= 126E                      20  COM_ADDR    DC.W    HELP        ; Command addresses table
00001080= 1282                      21              DC.W    MDSP
00001082= 130A                      22              DC.W    MM
00001084= 130C                      23              DC.W    EXIT
00001086                            24              
00001086= 48 45 4C 50 3A 20 ...     25  HELP_MSG    DC.B    'HELP: Displays this message',$A,$A,$D
000010A4= 4D 44 53 50 3A 20 ...     26              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
000010CF= 44 65 66 61 75 6C ...     27              DC.B    'Default address2: address1 + 16',$A,$D
000010F0= 4D 44 53 50 20 3C ...     28              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
00001126= 4D 4D 3A 20 4D 6F ...     29              DC.B    'MM: Modifies Data In Memory',$A,$D
00001143= 44 65 66 61 75 6C ...     30              DC.B    'Default: Displays one byte',$A,$D
0000115F= 3B 57 3A 20 44 69 ...     31              DC.B    ';W: Displays One Word',$A,$D
00001176= 3B 4C 3A 20 44 69 ...     32              DC.B    ';L: Displays One Long Word',$A,$D
00001192= 4D 4D 20 3C 61 64 ...     33              DC.B    'MM <address>[;size]',$A,$A,$D
000011A8                            34              ** Add all others as I go
000011A8= 45 58 49 54 3A 20 ...     35              DC.B    'EXIT: Exit the monitor program eg: EXIT<CR>',0
000011D4                            36              
000011D4                            37  *** RUNNING PROGRAM ***
00001200                            38      ORG     $1200
00001200                            39  START:                  ; first instruction of program
00001200                            40  
00001200  =00000050                 41  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
00001200  =00003000                 42  STACK       EQU $3000
00001200  4FF8 3000                 43          LEA     STACK,A7
00001204  48E7 FFFE                 44          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to display them
00001208                            45  
00001208                            46          **Populate exception vector table
00001208                            47          
00001208                            48  *** MAIN: Prompt, execute and repeat ***
00001208  43F8 1000                 49          LEA     WELCOME,A1
0000120C  103C 000D                 50          MOVE.B  #13,D0
00001210  4E4F                      51          TRAP    #15
00001212  43F8 102C                 52  PROMPT  LEA     PROMPT_STR,A1  
00001216  103C 000E                 53          MOVE.B  #14,D0
0000121A  4E4F                      54          TRAP    #15     ; print out prompt
0000121C  9FFC 00000050             55          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input -- COULD GO BEFORE PROMPT (REF #1)
00001222  224F                      56          MOVEA.L A7,A1   ; input will go in stack
00001224  103C 0002                 57          MOVE.B  #2,D0
00001228  4E4F                      58          TRAP    #15     ; read user input, length stored in D1
0000122A                            59          
0000122A  49F8 1067                 60          LEA     COM_TABL,A4 ; beginning of command table
0000122E  4BF8 107E                 61          LEA     COM_ADDR,A5 ; end of command table
00001232  4283                      62          CLR.L   D3      ; will be the count of where the command is
00001234  4282                      63  SEARCH  CLR.L   D2
00001236  141C                      64          MOVE.B  (A4)+,D2   ; length of next command string
00001238  0402 0030                 65          SUBI.B  #$30,D2 ; convert ascii num to hex
0000123C  2C49                      66          MOVEA.L A1,A6   ; pointer to input string
0000123E  BD0C                      67  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
00001240  56CA FFFC                 68          DBNE    D2,CMP_B    ; keep comparing characters until length is over
00001244  4A42                      69          TST.W   D2
00001246  6D00 0012                 70          BLT     EXEC    ; loop was exhausted and all chars were equal
0000124A  D9C2                      71          ADDA.L  D2,A4   ; go to end of command
0000124C  5483                      72          ADDQ.L  #2,D3   ; else, increment offset by word size
0000124E  BBCC                      73          CMPA.L  A4,A5 ; end of COM_TABL
00001250  6CE2                      74          BGE     SEARCH  ; keep on searching
00001252                            75          
00001252  6100 00BE                 76          BSR     INVALID ; print invalid command message
00001256  6000 000E                 77          BRA     ENDLOOP ; prompt again
0000125A                            78          
0000125A  DBC3                      79  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
0000125C  267C 00000000             80          MOVEA.L #0,A3   ; clear A3, used for subroutine call
00001262  3655                      81          MOVEA.W (A5),A3 ; move that command's address to register
00001264  4E93                      82          JSR     (A3)    ; jump to that command's subroutine (below)
00001266                            83  
00001266  DFFC 00000050             84  ENDLOOP ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input -- COULD GO IN EXIT SUBROUTINE (REF #1)
0000126C  60A4                      85          BRA     PROMPT  ; prompt again
0000126E                            86  
0000126E                            87  *** DEBUGGING COMMANDS ***
0000126E  48E7 8040                 88  HELP    MOVEM.L D0/A1,-(A7) ; store used registers in stack
00001272  43F8 1086                 89          LEA     HELP_MSG,A1  
00001276  103C 000D                 90          MOVE.B  #13,D0
0000127A  4E4F                      91          TRAP    #15     ; print help message
0000127C  4CDF 0201                 92          MOVEM.L (A7)+,D0/A1 ; restore registers from stack
00001280  4E75                      93          RTS
00001282                            94          
00001282                            95  * For this subroutine and others, A6 contains the start of the command's parameters
00001282                            96  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
00001282  48E7 F070                 97  MDSP    MOVEM.L D0-D3/A1-A3,-(A7)
00001286  121E                      98          MOVE.B  (A6)+,D1    ; first '$'
00001288  0C01 0024                 99          CMPI.B  #$24,D1
0000128C  6600 0072                100          BNE     MDSPINV ; wrong command usage
00001290  6100 0094                101          BSR     MEM2HEX ; D1 has 1st address in hex
00001294  247C 00000000            102          MOVEA.L #0,A2   ; CLR.L A2 (not allowed)
0000129A  3441                     103          MOVEA.W D1,A2
0000129C  121E                     104          MOVE.B  (A6)+,D1    ; space in between addresses
0000129E  4A01                     105          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
000012A0  6600 000E                106          BNE     MDSPADDR2
000012A4  264A                     107          MOVEA.L A2,A3
000012A6  D7FC 00000010            108          ADDA.L  #16,A3  ; A3 = A2 +16
000012AC  6000 0012                109          BRA     MDSPLOOP
000012B0  121E                     110  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
000012B2  0C01 0024                111          CMPI.B  #$24,D1
000012B6  6600 0048                112          BNE     MDSPINV
000012BA  6100 006A                113          BSR     MEM2HEX ; D1 has 2nd address in hex
000012BE  2641                     114          MOVEA.L D1,A3
000012C0  224F                     115  MDSPLOOP    MOVEA.L A7,A1
000012C2  93FC 00000040            116          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
000012C8  133C 0000                117          MOVE.B  #$00,-(A1) ; null terminator
000012CC  133C 0020                118          MOVE.B  #$20,-(A1)  ; space
000012D0  133C 003E                119          MOVE.B  #$3E,-(A1)  ; '<' for nicer output
000012D4  220A                     120          MOVE.L  A2,D1
000012D6  6100 007E                121          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
000012DA  133C 0024                122          MOVE.B  #$24,-(A1)  ; '$' for nicer output
000012DE  103C 000E                123          MOVE.B  #14,D0
000012E2  4E4F                     124          TRAP    #15     ; print current memory address
000012E4                           125          ;MOVEA.L A7,A1   ; write on top to leverage memory usage
000012E4  133C 0000                126          MOVE.B  #$00,-(A1) ; null terminator
000012E8  133C 0020                127          MOVE.B  #$20,-(A1)  ; space
000012EC  221A                     128          MOVE.L  (A2)+,D1
000012EE  6100 0066                129          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
000012F2  103C 000D                130          MOVE.B  #13,D0
000012F6  4E4F                     131          TRAP    #15
000012F8  B7CA                     132          CMPA.L  A2,A3
000012FA  6EC4                     133          BGT     MDSPLOOP
000012FC  6000 0006                134          BRA     MDSPDONE
00001300  6100 0010                135  MDSPINV BSR     INVALID ; print invalid command message
00001304  4CDF 0E0F                136  MDSPDONE    MOVEM.L (A7)+,D0-D3/A1-A3
00001308  4E75                     137          RTS
0000130A                           138  
0000130A                           139  MM    
0000130A  4E75                     140          RTS
0000130C                           141  
0000130C  103C 0009                142  EXIT    MOVE.B  #9, D0
00001310  4E4F                     143          TRAP    #15     ; exit program
00001312                           144  
00001312                           145  *** HELPERS ***
00001312                           146  * Print INVALID message:
00001312  48E7 8040                147  INVALID MOVEM.L D0/A1,-(A7)
00001316  43F8 103A                148          LEA     INVALID_MSG,A1  ; command was invalid
0000131A  103C 000D                149          MOVE.B  #13,D0
0000131E  4E4F                     150          TRAP    #15     ; output invalid command
00001320  4CDF 0201                151          MOVEM.L (A7)+,D0/A1
00001324  4E75                     152          RTS
00001326                           153  
00001326                           154  * Takes 4 digits from (A6) in ascii and puts them in D1 as hex: -- COULD MAKE IT TAKE X DIGITS (ref #2)
00001326  48E7 8100                155  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
0000132A  7004                     156          MOVE.L  #4,D0   ; number of digits
0000132C  4281                     157          CLR.L   D1
0000132E  1E1E                     158  M2HNEXT MOVE.B (A6)+,D7    ; read in next byte
00001330  6100 0014                159          BSR     BYTE2HEX    ; byte to hex digit, in D7
00001334  D207                     160          ADD.B   D7,D1
00001336  5380                     161          SUBQ.L  #1,D0   ; decrement counter
00001338  6700 0006                162          BEQ     MEM2HEXDONE ; done
0000133C  E981                     163          ASL.L   #4,D1   ; skip this the last time
0000133E  60EE                     164          BRA     M2HNEXT ; loop again because not done
00001340  4CDF 0081                165  MEM2HEXDONE  MOVEM.L (A7)+,D0/D7    ; restore from stack
00001344  4E75                     166          RTS
00001346                           167  
00001346                           168  * Takes byte in ascii in D7 and converts it to hex in D7:
00001346                           169  * Assumes 0-9 or A-F
00001346  0C07 0040                170  BYTE2HEX CMPI.B #$40,D7
0000134A  6D00 0004                171          BLT B2HSKIPPY
0000134E  5F07                     172          SUBQ.B  #$7,D7   ; only for A-F
00001350  0407 0030                173  B2HSKIPPY   SUB.B   #$30,D7
00001354  4E75                     174          RTS
00001356                           175          
00001356                           176  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001356  48E7 A100                177  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
0000135A  4280                     178          CLR.L   D0   ; counter
0000135C  2E01                     179  H2MNEXT MOVE.L  D1,D7
0000135E                           180          ;MOVE.L  D0,D2
0000135E                           181  ;H2MLEFT LSL.L   #4,D7    ; move by corresponding amount so at top
0000135E                           182   ;       SUBQ.W  #1,D2
0000135E                           183    ;      BGT     H2MLEFT
0000135E  2400                     184          MOVE.L D0,D2
00001360  5342                     185  H2MRIGHT    SUBQ.W  #1,D2
00001362  6D00 0006                186          BLT     H2MDONE
00001366  E88F                     187          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001368  60F6                     188          BRA     H2MRIGHT
0000136A  6100 0012                189  H2MDONE BSR     HEX2BYTE ; convert to ascii in D7
0000136E  1307                     190          MOVE.B  D7,-(A1)
00001370  5240                     191          ADDQ.W  #1,D0
00001372  0C40 0008                192          CMPI.W  #8,D0
00001376  6DE4                     193          BLT     H2MNEXT
00001378  4CDF 0085                194          MOVEM.L (A7)+,D0/D2/D7
0000137C  4E75                     195          RTS
0000137E                           196  
0000137E                           197  * Takes hex digit in D7 and converts it to ascii byte in D7:
0000137E                           198  * Assumes 0-9 or A-F
0000137E  CEBC 0000000F            199  HEX2BYTE AND.L  #$0F,D7 ; mask and take only smallest hex digit
00001384  0C07 000A                200          CMPI.B  #$A,D7
00001388  6D00 0004                201          BLT H2BSKIPPY
0000138C  5E07                     202          ADDQ.B  #$7,D7   ; only for A-F
0000138E  0607 0030                203  H2BSKIPPY   ADD.B   #$30,D7
00001392  4E75                     204          RTS
00001394                           205  
00001394                           206      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B2HSKIPPY           1350
BYTE2HEX            1346
CMP_B               123E
COM_ADDR            107E
COM_TABL            1067
ENDLOOP             1266
EXEC                125A
EXIT                130C
H2BSKIPPY           138E
H2MDONE             136A
H2MNEXT             135C
H2MRIGHT            1360
HELP                126E
HELP_MSG            1086
HEX2BYTE            137E
HEX2MEM             1356
INVALID             1312
INVALID_MSG         103A
M2HNEXT             132E
MAX_IN_LEN          50
MDSP                1282
MDSPADDR2           12B0
MDSPDONE            1304
MDSPINV             1300
MDSPLOOP            12C0
MEM2HEX             1326
MEM2HEXDONE         1340
MM                  130A
PROMPT              1212
PROMPT_STR          102C
SEARCH              1234
STACK               3000
START               1200
WELCOME             1000

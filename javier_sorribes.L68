000014CE Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/20/2017 01:05:13

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 54 48 41 4E 4B 20 ...     11  GOODBYE     DC.B    'THANK YOU FOR USING MONITOR441, SEE YOU SOON!',0
0000105A= 0A 0D 4D 4F 4E 49 ...     12  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
00001068= 49 4E 56 41 4C 49 ...     13  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
00001079= 54 79 70 65 20 48 ...     14              DC.B    'Type HELP for command usage',0
00001095                            15  
00001095= 34 48 45 4C 50 00         16  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000109B= 34 4D 44 53 50 20         17              DC.B    '4MDSP',$20  ; number specifies length of word 
000010A1= 35 53 4F 52 54 57 20      18              DC.B    '5SORTW',$20    ; used for SEARCH (not input)
000010A8= 32 4D 4D 00               19              DC.B    '2MM',0
000010AC= 32 44 46 00               20              DC.B    '2DF',0
000010B0= 34 45 58 49 54 00         21              DC.B    '4EXIT',0
000010B6= 34 43 4F 4E 56 20         22              DC.B    '4CONV',$20
000010BC                            23              
000010BC= 1578                      24  COM_ADDR    DC.W    HELP        ; Command addresses table
000010BE= 158C                      25              DC.W    MDSP
000010C0= 160E                      26              DC.W    SORTW
000010C2= 1696                      27              DC.W    MM
000010C4= 1698                      28              DC.W    DF
000010C6= 16CC                      29              DC.W    EXIT
000010C8= 16EA                      30              DC.W    CONV
000010CA                            31              
000010CA= 48 45 4C 50 3A 20 ...     32  HELP_MSG    DC.B    'HELP: Displays This Message',$A,$A,$D
000010E8= 4D 44 53 50 3A 20 ...     33              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
00001113= 44 65 66 61 75 6C ...     34              DC.B    'Default address2: address1 + 16',$A,$D
00001134= 4D 44 53 50 20 3C ...     35              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
0000116A= 53 4F 52 54 57 3A ...     36              DC.B    'SORTW: Sorts Unsigned Words In A Memory Block',$A,$D
00001199= 42 6F 74 68 20 61 ...     37              DC.B    'Both address1 and address2 are inclusive',$A,$D
000011C3= 44 65 66 61 75 6C ...     38              DC.B    'Default order: descending',$A,$D
000011DE= 53 4F 52 54 57 20 ...     39              DC.B    'SORTW <address1> <address2>[ A|D] eg: SORTW $2000 $201E A<CR>',$A,$A,$D
0000121E= 4D 4D 3A 20 4D 6F ...     40              DC.B    'MM: Modifies Data In Memory',$A,$D
0000123B= 44 65 66 61 75 6C ...     41              DC.B    'Default: Displays one byte',$A,$D
00001257= 57 3A 20 44 69 73 ...     42              DC.B    'W: Displays one word',$A,$D
0000126D= 4C 3A 20 44 69 73 ...     43              DC.B    'L: Displays one long word',$A,$D
00001288= 4D 4D 20 3C 61 64 ...     44              DC.B    'MM <address>[ size]',$A,$A,$D
0000129E                            45              ** Add all others as I go
0000129E= 44 46 3A 20 44 69 ...     46              DC.B    'DF: Displays All Formatted Registers eg: DF<CR>',$A,$A,$D
000012D0= 45 58 49 54 3A 20 ...     47              DC.B    'EXIT: Exit The Monitor Program eg: EXIT<CR>',$A,$A,$D
000012FE= 43 4F 4E 56 3A 20 ...     48              DC.B    'CONV: Convert Hex to Decimal, Or Vice Versa',$A,$D
0000132B= 43 4F 4E 56 20 5B ...     49              DC.B    'CONV [$]num eg: CONV 16<CR> returns $10',0
00001353                            50              
00001353= 44 30 3D 58 58 58 ...     51  DF_MSG      DC.B    'D0=XXXXXXXX D1=XXXXXXXX D2=XXXXXXXX D3=XXXXXXXX',$A,$D
00001384= 44 34 3D 58 58 58 ...     52              DC.B    'D4=XXXXXXXX D5=XXXXXXXX D6=XXXXXXXX D7=XXXXXXXX',$A,$D
000013B5= 41 30 3D 58 58 58 ...     53              DC.B    'A0=XXXXXXXX A1=XXXXXXXX A2=XXXXXXXX A3=XXXXXXXX',$A,$D
000013E6= 41 34 3D 58 58 58 ...     54              DC.B    'A4=XXXXXXXX A5=XXXXXXXX A6=XXXXXXXX A7=XXXXXXXX',0
00001416                            55  DF_MSG_END
00001416                            56           
00001416= 0D 41 64 64 72 65 ...     57  ADDRERR_MSG DC.B    $D,'Address Error Exception',0   
0000142F= 0D 42 75 73 20 45 ...     58  BERR_MSG    DC.B    $D,'Bus Error Exception',0
00001444= 0D 49 6C 6C 65 67 ...     59  ILLINS_MSG  DC.B    $D,'Illegal Instructor Exception',0
00001462= 0D 50 72 69 76 69 ...     60  PRIVERR_MSG DC.B    $D,'Privilege Error Exception',0
0000147D= 0D 44 69 76 69 73 ...     61  DIV0_MSG    DC.B    $D,'Division By Zero Exception',0
00001499= 0D 43 68 65 63 6B ...     62  CHKERR_MSG  DC.B    $D,'Check Exception',0
000014AA= 0D 4C 69 6E 65 20 ...     63  LINEA_MSG   DC.B    $D,'Line A Exception',0
000014BC= 0D 4C 69 6E 65 20 ...     64  LINEF_MSG   DC.B    $D,'Line F Exception',0
000014CE                            65              
000014CE                            66  *** RUNNING PROGRAM ***
000014CE                            67      ;ORG     $1200 --> allow for as much as necessary before this, and add program right after it
000014CE                            68  START:                  ; first instruction of program
000014CE                            69  
000014CE  =00000050                 70  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
000014CE  =00002FFC                 71  STACK       EQU $2FFC   ; $3000 minus a long word because A7 will be stored first
000014CE  21CF 2FFC                 72          MOVE.L  A7,STACK    ; store original location of stack beforehand
000014D2  4FF8 2FFC                 73          LEA     STACK,A7
000014D6  48E7 FFFE                 74          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to restore them
000014DA                            75  
000014DA                            76  ** Populate exception vector table ***
000014DA  21FC 00001844 0008        77          MOVE.L  #BERR,$8
000014E2  21FC 0000182E 000C        78          MOVE.L  #ADDRERR,$C
000014EA  21FC 0000185A 0010        79          MOVE.L  #ILLINS,$10
000014F2  21FC 00001872 0014        80          MOVE.L  #DIV0,$14
000014FA  21FC 0000187E 0018        81          MOVE.L  #CHKERR,$18
00001502  21FC 00001866 0020        82          MOVE.L  #PRIVERR,$20
0000150A  21FC 0000188A 0028        83          MOVE.L  #LINEA,$28
00001512  21FC 00001896 002C        84          MOVE.L  #LINEF,$2C
0000151A                            85          
0000151A                            86  *** MAIN: Prompt, execute and repeat ***
0000151A  43F8 1000                 87          LEA     WELCOME,A1
0000151E  103C 000D                 88          MOVE.B  #13,D0
00001522  4E4F                      89          TRAP    #15     ; display welcome message
00001524  9FFC 00000050             90          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input (do only once)
0000152A  43F8 105A                 91  PROMPT  LEA     PROMPT_STR,A1  
0000152E  103C 000E                 92          MOVE.B  #14,D0
00001532  4E4F                      93          TRAP    #15     ; print out prompt
00001534  224F                      94          MOVEA.L A7,A1   ; input will go in stack
00001536  103C 0002                 95          MOVE.B  #2,D0
0000153A  4E4F                      96          TRAP    #15     ; read user input, length stored in D1
0000153C                            97          
0000153C  49F8 1095                 98          LEA     COM_TABL,A4 ; beginning of command table
00001540  4BF8 10BC                 99          LEA     COM_ADDR,A5 ; end of command table
00001544  4283                     100          CLR.L   D3      ; will be the count of where the command is
00001546  4282                     101  SEARCH  CLR.L   D2
00001548  141C                     102          MOVE.B  (A4)+,D2   ; length of next command string
0000154A  0402 0030                103          SUBI.B  #$30,D2 ; convert ascii num to hex
0000154E  2C49                     104          MOVEA.L A1,A6   ; pointer to input string
00001550  BD0C                     105  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
00001552  56CA FFFC                106          DBNE    D2,CMP_B    ; keep comparing characters until length is over
00001556  4A42                     107          TST.W   D2
00001558  6D00 0010                108          BLT     EXEC    ; loop was exhausted and all chars were equal
0000155C  D9C2                     109          ADDA.L  D2,A4   ; go to end of command
0000155E  5483                     110          ADDQ.L  #2,D3   ; else, increment offset by word size
00001560  BBCC                     111          CMPA.L  A4,A5 ; end of COM_TABL
00001562  6CE2                     112          BGE     SEARCH  ; keep on searching
00001564                           113          
00001564  6100 01BC                114          BSR     INVALID ; print invalid command message
00001568  60C0                     115          BRA     PROMPT ; prompt again
0000156A                           116          
0000156A  DBC3                     117  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
0000156C  267C 00000000            118          MOVEA.L #0,A3   ; clear A3, used for subroutine call
00001572  3655                     119          MOVEA.W (A5),A3 ; move that command's address to register
00001574  4E93                     120          JSR     (A3)    ; jump to that command's subroutine (below)
00001576                           121  
00001576  60B2                     122          BRA     PROMPT  ; prompt again
00001578                           123  
00001578                           124  *** DEBUGGING COMMANDS ***
00001578                           125  * HELP -- displays help message
00001578  48E7 8040                126  HELP    MOVEM.L D0/A1,-(A7) ; store used registers in stack
0000157C  43F8 10CA                127          LEA     HELP_MSG,A1  
00001580  103C 000D                128          MOVE.B  #13,D0
00001584  4E4F                     129          TRAP    #15     ; print help message
00001586  4CDF 0201                130          MOVEM.L (A7)+,D0/A1 ; restore registers from stack
0000158A  4E75                     131          RTS
0000158C                           132          
0000158C                           133  * For this subroutine and others, A6 contains the start of the command's parameters
0000158C                           134  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
0000158C                           135  
0000158C                           136  * MDSP -- displays memory block
0000158C  48E7 F878                137  MDSP    MOVEM.L D0-D4/A1-A4,-(A7)
00001590  121E                     138          MOVE.B  (A6)+,D1    ; first '$'
00001592  0C01 0024                139          CMPI.B  #$24,D1 ; is it '$'?
00001596  6600 006C                140          BNE     MDSPINV ; wrong command usage
0000159A  6100 019A                141          BSR     MEM2HEX ; D1 has 1st address in hex
0000159E  2441                     142          MOVEA.L D1,A2   ;store in A2
000015A0  121E                     143          MOVE.B  (A6)+,D1    ; space in between addresses
000015A2  4A01                     144          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
000015A4  6600 000E                145          BNE     MDSPADDR2
000015A8  264A                     146          MOVEA.L A2,A3
000015AA  D7FC 00000010            147          ADDA.L  #16,A3  ; A3 = A2 +16
000015B0  6000 0012                148          BRA     MDSPLOOP
000015B4  121E                     149  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
000015B6  0C01 0024                150          CMPI.B  #$24,D1
000015BA  6600 0048                151          BNE     MDSPINV
000015BE  6100 0176                152          BSR     MEM2HEX ; D1 has 2nd address in hex
000015C2  2641                     153          MOVEA.L D1,A3
000015C4  224F                     154  MDSPLOOP    MOVEA.L A7,A1
000015C6  93FC 00000040            155          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
000015CC  133C 0000                156          MOVE.B  #$00,-(A1) ; null terminator
000015D0  133C 0020                157          MOVE.B  #$20,-(A1)  ; space
000015D4  133C 003E                158          MOVE.B  #$3E,-(A1)  ; '<' for nicer output
000015D8  220A                     159          MOVE.L  A2,D1
000015DA  6100 0196                160          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
000015DE  133C 0024                161          MOVE.B  #$24,-(A1)  ; '$' for nicer output
000015E2  103C 000E                162          MOVE.B  #14,D0
000015E6  4E4F                     163          TRAP    #15     ; print current memory address
000015E8  133C 0000                164          MOVE.B  #$00,-(A1) ; null terminator
000015EC  133C 0020                165          MOVE.B  #$20,-(A1)  ; space
000015F0  221A                     166          MOVE.L  (A2)+,D1
000015F2  6100 017E                167          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
000015F6  103C 000D                168          MOVE.B  #13,D0
000015FA  4E4F                     169          TRAP    #15     ; print
000015FC  B7CA                     170          CMPA.L  A2,A3
000015FE  6EC4                     171          BGT     MDSPLOOP
00001600  6000 0006                172          BRA     MDSPDONE
00001604  6100 011C                173  MDSPINV BSR     INVALID ; print invalid command message
00001608  4CDF 1E1F                174  MDSPDONE    MOVEM.L (A7)+,D0-D4/A1-A4
0000160C  4E75                     175          RTS
0000160E                           176  
0000160E                           177  * SORTW -- implements bubble sort (unsigned numbers)
0000160E  48E7 F878                178  SORTW   MOVEM.L D0-D4/A1-A4,-(A7)
00001612  121E                     179          MOVE.B  (A6)+,D1    ; first '$'
00001614  0C01 0024                180          CMPI.B  #$24,D1     ; is it '$'?
00001618  6600 0072                181          BNE     SORTWINV    ; wrong command usage
0000161C  6100 0118                182          BSR     MEM2HEX     ; D1 has 1st address in hex
00001620  2441                     183          MOVEA.L D1,A2       ; store in A2
00001622  121E                     184          MOVE.B  (A6)+,D1    ; space in between addresses
00001624  0C01 0020                185          CMPI.B  #$20,D1     ; is it ' '?
00001628  6600 0062                186          BNE     SORTWINV    ; wrong command usage
0000162C  121E                     187          MOVE.B  (A6)+,D1    ; second '$'
0000162E  0C01 0024                188          CMPI.B  #$24,D1     ; is it '$'?
00001632  6600 0058                189          BNE     SORTWINV    ; wrong command usage
00001636  6100 00FE                190          BSR     MEM2HEX     ; D1 has now the 2nd address
0000163A  2641                     191          MOVEA.L D1,A3       ; store in A3
0000163C  121E                     192          MOVE.B  (A6)+,D1    ; space 
0000163E  0C01 0000                193          CMPI.B  #$00,D1     ; is it NULL?
00001642  6700 001C                194          BEQ     SORTWDEF    ; use default: descending (D1=0)
00001646  0C01 0020                195          CMPI.B  #$20,D1     ; or is it ' '?
0000164A  6600 0040                196          BNE     SORTWINV    ; wrong command usage
0000164E  121E                     197          MOVE.B  (A6)+,D1    ; char either 'A' or 'D'
00001650  0C01 0041                198          CMPI.B  #$41,D1     ; is it 'A'?
00001654  6700 000C                199          BEQ     SORTWLOOP   ; if so, D1 marks ascending
00001658  0C01 0044                200          CMPI.B  #$44,D1     ; else, is it 'D'?
0000165C  6600 002E                201          BNE     SORTWINV    ; if it isn't, input was invalid
00001660  4281                     202  SORTWDEF    CLR.L   D1          ; if it is, D1=0 marks descending
00001662  284A                     203  SORTWLOOP   MOVEA.L A2,A4   ; first address copied into A4
00001664  4A01                     204  SORTWCMP    TST.B   D1      ; tells us whether ascending or descending
00001666  6700 000C                205          BEQ     SORTWD  ; do descending
0000166A  B94C                     206  SORTWA  CMP.W   (A4)+,(A4)+ ; compare next two numbers
0000166C  6500 0016                207          BCS     SORTWSWAP   ; swap if not in ascending order (if 1st>2nd)
00001670  6000 0008                208          BRA     SORTWNEXT   ; otherwise, move on
00001674  B94C                     209  SORTWD  CMP.W   (A4)+,(A4)+ ; compare next two numbers
00001676  6200 000C                210          BHI     SORTWSWAP   ; swap if not in descending order (if 2nd>1st)
0000167A  558C                     211  SORTWNEXT   SUBQ.L  #2,A4   ; look back at previous number
0000167C  B7CC                     212          CMP.L   A4,A3       
0000167E  66E4                     213          BNE     SORTWCMP    ; keep comparing if not at end yet (A3 inclusive)
00001680  6000 000E                214          BRA     SORTWDONE   ; else, done
00001684  2824                     215  SORTWSWAP MOVE.L  -(A4),D4   ; move both words to register
00001686  4844                     216          SWAP.W  D4  ; swap the two words 
00001688  2884                     217          MOVE.L  D4,(A4) ; write them back
0000168A  60D6                     218          BRA     SORTWLOOP   ; loop again from start
0000168C  6100 0094                219  SORTWINV    BSR INVALID
00001690  4CDF 1E1F                220  SORTWDONE   MOVEM.L (A7)+,D0-D4/A1-A4
00001694  4E75                     221          RTS
00001696                           222  
00001696                           223  * MM -- 
00001696                           224  MM    
00001696  4E75                     225          RTS
00001698                           226          
00001698                           227  * DF -- displays formatted registers
00001698  48E7 E0C0                228  DF      MOVEM.L D0-D2/A0-A1,-(A7)
0000169C  41F8 2FFC                229          LEA     STACK,A0
000016A0  5888                     230          ADDA.L  #4,A0   ; placed after A7 in stack
000016A2  43F8 1416                231          LEA     DF_MSG_END,A1
000016A6  5389                     232  DFLOOP  SUBQ.L  #1,A1   ; pass the $A at end of each line
000016A8  7403                     233          MOVE.L  #3,D2   ; number of registers per line - 1
000016AA  2220                     234  DFLINE  MOVE.L  -(A0),D1    ; put register value in D1
000016AC  6100 00C4                235          BSR     HEX2MEM     ; will store D1 in -8(A1)
000016B0  5989                     236          SUBQ.L  #4,A1   ; skip other characters
000016B2  51CA FFF6                237          DBF     D2,DFLINE   ; keep looping till line done       
000016B6  B3FC 00001353            238          CMP.L   #DF_MSG,A1
000016BC  6EE8                     239          BGT     DFLOOP
000016BE  5289                     240          ADDQ.L  #1,A1   ; put back at the front of the message
000016C0  103C 000D                241          MOVE.B  #13,D0
000016C4  4E4F                     242          TRAP    #15     ; print register value
000016C6  4CDF 0307                243          MOVEM.L (A7)+,D0-D2/A0-A1
000016CA  4E75                     244          RTS
000016CC                           245  
000016CC                           246  * EXIT -- terminates the program
000016CC  43F8 102C                247  EXIT    LEA     GOODBYE,A1
000016D0  103C 000D                248          MOVE.B  #13,D0
000016D4  4E4F                     249          TRAP    #15     ; print goodbye message
000016D6  588F                     250          ADDA.L  #4,A7   ; move past the PC stored in the stack
000016D8  DFFC 00000050            251          ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input
000016DE  4CDF 7FFF                252          MOVEM.L (A7)+,D0-D7/A0-A6   ; restore all registers in stack
000016E2  2E78 2FFC                253          MOVEA.L STACK,A7
000016E6  6000 021A                254          BRA     END     ; exit program
000016EA                           255          
000016EA                           256  * The 2 extra commands:
000016EA                           257  * CONV -- takes in hex and returns decimal, or viceversa
000016EA  48E7 C040                258  CONV    MOVEM.L D0-D1/A1,-(A7)
000016EE  121E                     259          MOVE.B  (A6)+,D1
000016F0  0C01 0024                260          CMPI.B  #$24,D1 ; is it '$'?
000016F4  6700 0016                261          BEQ     CONVH2D ; if so, hex to dec
000016F8  538E                     262  CONVD2H SUBQ.L  #1,A6   ; point back at first number
000016FA  6100 00E2                263          BSR     MEM2DEC ; D1 contains the decimal number
000016FE  224E                     264          MOVEA.L A6,A1   ; number ready to print
00001700  6100 0098                265          BSR     HEX2MEM_NOZ ; that number is written as hex in memory
00001704  133C 0024                266          MOVE.B  #'$',-(A1)
00001708  6000 000C                267          BRA     CONVDONE
0000170C  6100 0028                268  CONVH2D BSR     MEM2HEX ; convert ascii to hex
00001710  224E                     269          MOVEA.L A6,A1   ;number ready to print
00001712  6100 00F8                270          BSR     DEC2MEM ; convert it back to ascii but as decimal
00001716  103C 000D                271  CONVDONE MOVE.B #13,D0
0000171A  4E4F                     272          TRAP    #15 ; print result
0000171C  4CDF 0203                273          MOVEM.L (A7)+,D0-D1/A1
00001720  4E75                     274          RTS
00001722                           275  
00001722                           276  *** HELPERS ***
00001722                           277  * Print INVALID message:
00001722  48E7 8040                278  INVALID MOVEM.L D0/A1,-(A7)
00001726  43F8 1068                279          LEA     INVALID_MSG,A1  ; command was invalid
0000172A  103C 000D                280          MOVE.B  #13,D0
0000172E  4E4F                     281          TRAP    #15     ; output invalid command
00001730  4CDF 0201                282          MOVEM.L (A7)+,D0/A1
00001734  4E75                     283          RTS
00001736                           284  
00001736                           285  * Takes X digits from (A6) in ascii and puts them in D1 as hex:
00001736  48E7 8100                286  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
0000173A  4281                     287          CLR.L   D1
0000173C  1E1E                     288          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000173E  0C07 0030                289          CMPI.B  #$30,D7
00001742  6D00 0016                290          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001746  6100 001A                291  M2HNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
0000174A  D207                     292          ADD.B   D7,D1
0000174C  1E1E                     293          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000174E  0C07 0030                294          CMPI.B  #$30,D7
00001752  6D00 0006                295          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001756  E981                     296          ASL.L   #4,D1   ; skip this the last time
00001758  60EC                     297          BRA     M2HNEXT ; loop again because not done
0000175A  538E                     298  M2HDONE SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
0000175C  4CDF 0081                299          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001760  4E75                     300          RTS
00001762                           301  
00001762                           302  * Takes byte in ascii in D7 and converts it to digit in D7:
00001762                           303  * Assumes 0-9 or A-F
00001762  0C07 0040                304  ASCII2NUM   CMPI.B #$40,D7
00001766  6D00 0004                305          BLT A2NSKIPPY
0000176A  5F07                     306          SUBQ.B  #$7,D7   ; only for A-F
0000176C  0407 0030                307  A2NSKIPPY   SUB.B   #$30,D7
00001770  4E75                     308          RTS
00001772                           309          
00001772                           310  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001772  48E7 A100                311  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001776  4280                     312          CLR.L   D0   ; counter
00001778  2E01                     313  H2MNEXT MOVE.L  D1,D7
0000177A  2400                     314          MOVE.L D0,D2
0000177C  5342                     315  H2MRIGHT    SUBQ.W  #1,D2
0000177E  6D00 0006                316          BLT     H2MDONE
00001782  E88F                     317          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001784  60F6                     318          BRA     H2MRIGHT
00001786  6100 0040                319  H2MDONE BSR     NUM2ASCII   ; convert to ascii in D7
0000178A  1307                     320          MOVE.B  D7,-(A1)
0000178C  5240                     321          ADDQ.W  #1,D0
0000178E  0C40 0008                322          CMPI.W  #8,D0
00001792  6DE4                     323          BLT     H2MNEXT
00001794  4CDF 0085                324          MOVEM.L (A7)+,D0/D2/D7
00001798  4E75                     325          RTS
0000179A                           326          
0000179A                           327  * Takes X digits from D1 in hex and puts them into -X(A1) in ascii (no trailing zeros):
0000179A  48E7 A100                328  HEX2MEM_NOZ MOVEM.L D0/D2/D7,-(A7)    ; store in stack
0000179E  4280                     329          CLR.L   D0   ; counter
000017A0  2E01                     330  H2MZNEXT MOVE.L  D1,D7
000017A2  2400                     331          MOVE.L D0,D2
000017A4  5342                     332  H2MZRIGHT    SUBQ.W  #1,D2
000017A6  6D00 0006                333          BLT     H2MZDONE
000017AA  E88F                     334          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
000017AC  60F6                     335          BRA     H2MZRIGHT
000017AE  4A87                     336  H2MZDONE TST.L   D7
000017B0  6700 0010                337          BEQ     H2MZEND      ; if number done
000017B4  6100 0012                338          BSR     NUM2ASCII   ; convert to ascii in D7
000017B8  1307                     339          MOVE.B  D7,-(A1)
000017BA  5240                     340          ADDQ.W  #1,D0
000017BC  0C40 0008                341          CMPI.W  #8,D0
000017C0  6DDE                     342          BLT     H2MZNEXT
000017C2  4CDF 0085                343  H2MZEND  MOVEM.L (A7)+,D0/D2/D7
000017C6  4E75                     344          RTS
000017C8                           345  
000017C8                           346  * Takes digit in D7 and converts it to ascii byte in D7:
000017C8                           347  * Assumes 0-9 or A-F
000017C8  CEBC 0000000F            348  NUM2ASCII   AND.L  #$0F,D7 ; mask and take only smallest hex digit
000017CE  0C07 000A                349          CMPI.B  #$A,D7
000017D2  6D00 0004                350          BLT N2ASKIPPY
000017D6  5E07                     351          ADDQ.B  #$7,D7   ; only for A-F
000017D8  0607 0030                352  N2ASKIPPY   ADD.B   #$30,D7
000017DC  4E75                     353          RTS
000017DE                           354          
000017DE                           355  * Takes X digits from (A6) in ascii and puts them in D1 as dec:
000017DE  48E7 8100                356  MEM2DEC MOVEM.L D0/D7,-(A7)    ; store in stack
000017E2  4281                     357          CLR.L   D1
000017E4  1E1E                     358          MOVE.B (A6)+,D7    ; read in next byte (prime read)
000017E6  0C07 0030                359          CMPI.B  #$30,D7
000017EA  6D00 0018                360          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
000017EE  6100 FF72                361  M2DNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
000017F2  D207                     362          ADD.B   D7,D1
000017F4  1E1E                     363          MOVE.B (A6)+,D7    ; read in next byte (prime read)
000017F6  0C07 0030                364          CMPI.B  #$30,D7
000017FA  6D00 0008                365          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
000017FE  C2FC 000A                366          MULU    #10,D1   ; skip this the last time
00001802  60EA                     367          BRA     M2DNEXT ; loop again because not done
00001804  538E                     368  M2DDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
00001806  4CDF 0081                369          MOVEM.L (A7)+,D0/D7    ; restore from stack
0000180A  4E75                     370          RTS
0000180C                           371  
0000180C                           372  * Takes number from D1 in dec and puts them into -X(A1) in ascii:
0000180C  48E7 2100                373  DEC2MEM MOVEM.L D2/D7,-(A7)    ; store in stack
00001810  2401                     374          MOVE.L  D1,D2
00001812  84FC 000A                375  D2MLOOP DIVU    #10,D2
00001816  2E02                     376          MOVE.L  D2,D7
00001818  4847                     377          SWAP.W  D7
0000181A  61AC                     378          BSR     NUM2ASCII
0000181C  1307                     379          MOVE.B  D7,-(A1)
0000181E  C4BC 0000FFFF            380          AND.L   #$0000FFFF,D2 ; make sure we use only word in next divisions
00001824  4A42                     381          TST.W   D2
00001826  66EA                     382          BNE     D2MLOOP
00001828  4CDF 0084                383          MOVEM.L (A7)+,D2/D7
0000182C  4E75                     384          RTS
0000182E                           385          
0000182E                           386  *** EXCEPTION HANDLERS ***
0000182E  48E7 8040                387  ADDRERR MOVEM.L D0/A1,-(A7)
00001832  48E7 4080                388          MOVEM.L D1/A0,-(A7) ; specific for this interrupt
00001836  43F8 1416                389          LEA     ADDRERR_MSG,A1
0000183A  103C 000D                390          MOVE.B  #13,D0
0000183E  4E4F                     391          TRAP    #15
00001840  6000 0060                392          BRA     INTERR_REG  ; print the special registers
00001844  48E7 8040                393  BERR    MOVEM.L D0/A1,-(A7)
00001848  48E7 4080                394          MOVEM.L D1/A0,-(A7) ; specific for this interrupt
0000184C  43F8 142F                395          LEA     BERR_MSG,A1
00001850  103C 000D                396          MOVE.B  #13,D0
00001854  4E4F                     397          TRAP    #15
00001856  6000 004A                398          BRA     INTERR_REG  ; print the special registers
0000185A  48E7 8040                399  ILLINS  MOVEM.L D0/A1,-(A7)
0000185E  43F8 1444                400          LEA     ILLINS_MSG,A1
00001862  6000 007C                401          BRA     INTERR 
00001866  48E7 8040                402  PRIVERR MOVEM.L D0/A1,-(A7)
0000186A  43F8 1462                403          LEA     PRIVERR_MSG,A1
0000186E  6000 0070                404          BRA     INTERR 
00001872  48E7 8040                405  DIV0    MOVEM.L D0/A1,-(A7)
00001876  43F8 147D                406          LEA     DIV0_MSG,A1
0000187A  6000 0064                407          BRA     INTERR 
0000187E  48E7 8040                408  CHKERR  MOVEM.L D0/A1,-(A7)
00001882  43F8 1499                409          LEA     CHKERR_MSG,A1
00001886  6000 0058                410          BRA     INTERR 
0000188A  48E7 8040                411  LINEA   MOVEM.L D0/A1,-(A7)
0000188E  43F8 14AA                412          LEA     LINEA_MSG,A1
00001892  6000 004C                413          BRA     INTERR 
00001896  48E7 8040                414  LINEF   MOVEM.L D0/A1,-(A7)
0000189A  43F8 14BC                415          LEA     LINEF_MSG,A1
0000189E  6000 0040                416          BRA     INTERR
000018A2                           417  INTERR_REG  ; only BERR and ADDRERR do this
000018A2  204F                     418          MOVEA.L A7,A0
000018A4  D1FC 00000018            419          ADDA.L  #24,A0  ; A0 is pointing right below SSW, BA and IR
000018AA  227C 00002FFC            420          MOVEA.L #STACK,A1   ; top of stack for this part of the message
000018B0  93FC 0000003C            421          SUBA.L  #60,A1
000018B6  133C 0000                422          MOVE.B  #0,-(A1)    ; null terminator
000018BA  4281                     423          CLR.L   D1
000018BC  3220                     424          MOVE.W  -(A0),D1    ; SSW in D1
000018BE  6100 FEB2                425          BSR     HEX2MEM
000018C2  5889                     426          ADDQ.L  #4,A1       ; only want SSW to be a word
000018C4  133C 0020                427          MOVE.B  #' ',-(A1)
000018C8  2220                     428          MOVE.L  -(A0),D1    ; BA in D1
000018CA  6100 FEA6                429          BSR     HEX2MEM
000018CE  133C 0020                430          MOVE.B  #' ',-(A1)
000018D2  4281                     431          CLR.L   D1
000018D4  3220                     432          MOVE.W  -(A0),D1    ; IR in D1
000018D6  6100 FE9A                433          BSR     HEX2MEM
000018DA  5889                     434          ADDQ.L  #4,A1       ; only want IR to be a word
000018DC  4CDF 0102                435          MOVEM.L (A7)+,D1/A0 ; restore these specific registers
000018E0  103C 000D                436  INTERR  MOVE.B  #13,D0
000018E4  4E4F                     437          TRAP    #15 ; print corresponding message for that interrupt
000018E6  6100 FDB0                438          BSR     DF  ; print registers
000018EA  4CDF 0201                439          MOVEM.L (A7)+,D0/A1 ; do here to be able to modify values of A7
000018EE  4FF8 2FFC                440          LEA     STACK,A7    ; next 3 instructions put A7 at beginning of input space in stack
000018F2  9FFC 0000003C            441          SUBA.L  #60,A7  ; 15 registers that occupy 4 bytes each (2*4 = 8 bits)
000018F8  9FFC 00000050            442          SUBA.L  #MAX_IN_LEN,A7  ; the input space
000018FE  6000 FC2A                443          BRA     PROMPT
00001902                           444  
00001902                           445  END
00001902                           446      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2NSKIPPY           176C
ADDRERR             182E
ADDRERR_MSG         1416
ASCII2NUM           1762
BERR                1844
BERR_MSG            142F
CHKERR              187E
CHKERR_MSG          1499
CMP_B               1550
COM_ADDR            10BC
COM_TABL            1095
CONV                16EA
CONVD2H             16F8
CONVDONE            1716
CONVH2D             170C
D2MLOOP             1812
DEC2MEM             180C
DF                  1698
DFLINE              16AA
DFLOOP              16A6
DF_MSG              1353
DF_MSG_END          1416
DIV0                1872
DIV0_MSG            147D
END                 1902
EXEC                156A
EXIT                16CC
GOODBYE             102C
H2MDONE             1786
H2MNEXT             1778
H2MRIGHT            177C
H2MZDONE            17AE
H2MZEND             17C2
H2MZNEXT            17A0
H2MZRIGHT           17A4
HELP                1578
HELP_MSG            10CA
HEX2MEM             1772
HEX2MEM_NOZ         179A
ILLINS              185A
ILLINS_MSG          1444
INTERR              18E0
INTERR_REG          18A2
INVALID             1722
INVALID_MSG         1068
LINEA               188A
LINEA_MSG           14AA
LINEF               1896
LINEF_MSG           14BC
M2DDONE             1804
M2DNEXT             17EE
M2HDONE             175A
M2HNEXT             1746
MAX_IN_LEN          50
MDSP                158C
MDSPADDR2           15B4
MDSPDONE            1608
MDSPINV             1604
MDSPLOOP            15C4
MEM2DEC             17DE
MEM2HEX             1736
MM                  1696
N2ASKIPPY           17D8
NUM2ASCII           17C8
PRIVERR             1866
PRIVERR_MSG         1462
PROMPT              152A
PROMPT_STR          105A
SEARCH              1546
SORTW               160E
SORTWA              166A
SORTWCMP            1664
SORTWD              1674
SORTWDEF            1660
SORTWDONE           1690
SORTWINV            168C
SORTWLOOP           1662
SORTWNEXT           167A
SORTWSWAP           1684
STACK               2FFC
START               14CE
WELCOME             1000

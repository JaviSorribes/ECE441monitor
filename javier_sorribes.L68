00001876 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/24/2017 01:22:02

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 54 48 41 4E 4B 20 ...     11  GOODBYE     DC.B    'THANK YOU FOR USING MONITOR441, SEE YOU SOON!',0
0000105A= 0A 0D 4D 4F 4E 49 ...     12  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
00001068= 49 4E 56 41 4C 49 ...     13  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
00001079= 54 79 70 65 20 48 ...     14              DC.B    'Type HELP for command usage',0
00001095                            15  
00001095= 34 48 45 4C 50 00         16  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000109B= 34 4D 44 53 50 20         17              DC.B    '4MDSP',$20  ; number specifies length of word 
000010A1= 35 53 4F 52 54 57 20      18              DC.B    '5SORTW',$20    ; used for SEARCH (not input)
000010A8= 32 4D 4D 20               19              DC.B    '2MM',$20
000010AC= 32 4D 53 20               20              DC.B    '2MS',$20
000010B0= 32 42 46 20               21              DC.B    '2BF',$20
000010B4= 34 42 4D 4F 56 20         22              DC.B    '4BMOV',$20
000010BA= 34 42 54 53 54 20         23              DC.B    '4BTST',$20
000010C0= 34 42 53 43 48 20         24              DC.B    '4BSCH',$20
000010C6= 32 47 4F 20               25              DC.B    '2GO',$20
000010CA= 32 44 46 00               26              DC.B    '2DF',0
000010CE= 34 45 58 49 54 00         27              DC.B    '4EXIT',0
000010D4= 36 42 50 52 49 4E ...     28              DC.B    '6BPRINT',$20
000010DC= 34 43 4F 4E 56 20         29              DC.B    '4CONV',$20
000010E2                            30              
000010E2= 1920                      31  COM_ADDR    DC.W    HELP        ; Command addresses table
000010E4= 1944                      32              DC.W    MDSP
000010E6= 19C2                      33              DC.W    SORTW
000010E8= 1A4A                      34              DC.W    MM
000010EA= 1B88                      35              DC.W    MS
000010EC= 1BFA                      36              DC.W    BF
000010EE= 1C68                      37              DC.W    BMOV
000010F0= 1D12                      38              DC.W    BTST
000010F2= 1DF8                      39              DC.W    BSCH
000010F4= 1E74                      40              DC.W    GO
000010F6= 1E98                      41              DC.W    DF
000010F8= 1ECC                      42              DC.W    EXIT
000010FA= 1EEA                      43              DC.W    BPRINT
000010FC= 1F5C                      44              DC.W    CONV
000010FE                            45              
000010FE= 48 45 4C 50 3A 20 ...     46  HELP_MSG    DC.B    'HELP: Displays This Message',$A,$A,$D
0000111C= 4D 44 53 50 3A 20 ...     47              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
00001147= 44 65 66 61 75 6C ...     48              DC.B    'Default address2: address1 + 16',$A,$D
00001168= 4D 44 53 50 20 3C ...     49              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
0000119E= 53 4F 52 54 57 3A ...     50              DC.B    'SORTW: Sorts Unsigned Words In A Memory Block',$A,$D
000011CD= 42 6F 74 68 20 61 ...     51              DC.B    'Both address1 and address2 are inclusive',$A,$D
000011F7= 44 65 66 61 75 6C ...     52              DC.B    'Default order: descending',$A,$D
00001212= 53 4F 52 54 57 20 ...     53              DC.B    'SORTW <address1> <address2>[ A|D] eg: SORTW $2000 $201E A<CR>',$A,$A,$D
00001252= 4D 4D 3A 20 4D 6F ...     54              DC.B    'MM: Modifies Data In Memory',$A,$D
0000126F= 44 65 66 61 75 6C ...     55              DC.B    'Default: Displays one byte',$A,$D
0000128B= 57 3A 20 44 69 73 ...     56              DC.B    'W: Displays one word',$A,$D
000012A1= 4C 3A 20 44 69 73 ...     57              DC.B    'L: Displays one long word',$A,$D
000012BC= 4D 4D 20 3C 61 64 ...     58              DC.B    'MM <address>[ size]',$A,$A,$D
000012D2= 4D 53 3A 20 53 65 ...     59              DC.B    'MS: Set Memory To Given ASCII Or Hex',$A,$D
000012F8= 44 65 66 61 75 6C ...     60              DC.B    'Default: ASCII. Prepend $ for hex (byte, word or long)',$A,$D
00001330= 4D 53 20 3C 61 64 ...     61              DC.B    'MS <address1> [$]<string|hex> eg: MS $4000 Hello!',$A,$A,$D
00001364= 42 46 3A 20 46 69 ...     62              DC.B    'BF: Fills Block Of Memory With Word Pattern',$A,$D
00001391= 42 6F 74 68 20 61 ...     63              DC.B    'Both addresses must be even',$A,$D
000013AE= 44 65 66 61 75 6C ...     64              DC.B    'Default pattern: 0000',$A,$D
000013C5= 49 66 20 6C 65 73 ...     65              DC.B    'If less than 4 digits given, right justified and zero padded',$A,$D
00001403= 42 46 20 3C 61 64 ...     66              DC.B    'BF <address1> <address2>[ pattern] eg: BF $2000 $2200 4325<CR>',0
00001442= 42 4D 4F 56 3A 20 ...     67  HELP_MSG2   DC.B    'BMOV: Duplicate A Memory Block At Another Address',$A,$D
00001475= 4D 75 73 74 20 70 ...     68              DC.B    'Must provide two addresses (inclusive, exclusive) for first block',$A,$D
000014B8= 4F 6E 6C 79 20 6F ...     69              DC.B    'Only one address (inclusive start) for second block',$A,$D
000014ED= 42 4D 4F 56 20 3C ...     70              DC.B    'BMOV <address1.1> <address1.2> <address2>',$A,$A,$D
00001519= 42 54 53 54 3A 20 ...     71              DC.B    'BTST: Test Memory Block',$A,$D
00001532= 42 54 53 54 20 3C ...     72              DC.B    'BTST <address1> <address2>',$A,$A,$D
0000154F= 42 53 43 48 3A 20 ...     73              DC.B    'BSCH: Search In Memory Block',$A,$D
0000156D= 42 53 43 48 20 3C ...     74              DC.B    'BSCH <address1> <address2> <string>',$A,$A,$D
00001593= 47 4F 3A 20 45 78 ...     75              DC.B    'GO: Execute Another Program',$A,$D
000015B0= 47 4F 20 3C 61 64 ...     76              DC.B    'GO <address1>',$A,$A,$D
000015C0= 44 46 3A 20 44 69 ...     77              DC.B    'DF: Displays All Formatted Registers eg: DF<CR>',$A,$A,$D
000015F2= 45 58 49 54 3A 20 ...     78              DC.B    'EXIT: Exit The Monitor Program eg: EXIT<CR>',$A,$A,$D
00001620= 54 68 65 20 74 77 ...     79              DC.B    'The two extra commands:',$A,$A,$D
0000163A= 42 50 52 49 4E 54 ...     80              DC.B    'BPRINT: Print Block Of Memory',$A,$D
00001659= 44 65 66 61 75 6C ...     81              DC.B    'Default end: wherever a null char is found',$A,$D
00001685= 42 50 52 49 4E 54 ...     82              DC.B    'BPRINT <address1>[ <address2>]',$A,$A,$D
000016A6= 43 4F 4E 56 3A 20 ...     83              DC.B    'CONV: Convert Hex to Decimal, Or Vice Versa',$A,$D
000016D3= 43 4F 4E 56 20 5B ...     84              DC.B    'CONV [$]num eg: CONV 16<CR> returns $10',0
000016FB                            85              
000016FB= 44 30 3D 58 58 58 ...     86  DF_MSG      DC.B    'D0=XXXXXXXX D1=XXXXXXXX D2=XXXXXXXX D3=XXXXXXXX',$A,$D
0000172C= 44 34 3D 58 58 58 ...     87              DC.B    'D4=XXXXXXXX D5=XXXXXXXX D6=XXXXXXXX D7=XXXXXXXX',$A,$D
0000175D= 41 30 3D 58 58 58 ...     88              DC.B    'A0=XXXXXXXX A1=XXXXXXXX A2=XXXXXXXX A3=XXXXXXXX',$A,$D
0000178E= 41 34 3D 58 58 58 ...     89              DC.B    'A4=XXXXXXXX A5=XXXXXXXX A6=XXXXXXXX A7=XXXXXXXX',0
000017BE                            90  DF_MSG_END
000017BE                            91           
000017BE= 0D 41 64 64 72 65 ...     92  ADDRERR_MSG DC.B    $D,'Address Error Exception',0   
000017D7= 0D 42 75 73 20 45 ...     93  BERR_MSG    DC.B    $D,'Bus Error Exception',0
000017EC= 0D 49 6C 6C 65 67 ...     94  ILLINS_MSG  DC.B    $D,'Illegal Instructor Exception',0
0000180A= 0D 50 72 69 76 69 ...     95  PRIVERR_MSG DC.B    $D,'Privilege Error Exception',0
00001825= 0D 44 69 76 69 73 ...     96  DIV0_MSG    DC.B    $D,'Division By Zero Exception',0
00001841= 0D 43 68 65 63 6B ...     97  CHKERR_MSG  DC.B    $D,'Check Exception',0
00001852= 0D 4C 69 6E 65 20 ...     98  LINEA_MSG   DC.B    $D,'Line A Exception',0
00001864= 0D 4C 69 6E 65 20 ...     99  LINEF_MSG   DC.B    $D,'Line F Exception',0
00001876                           100              
00001876                           101  *** RUNNING PROGRAM ***
00001876                           102      ;ORG     $1200 --> allow for as much as necessary before this, and add program right after it
00001876                           103  START:                  ; first instruction of program
00001876                           104  
00001876  =00000050                105  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
00001876  =00002FFC                106  STACK       EQU $2FFC   ; $3000 minus a long word because A7 will be stored first
00001876  21CF 2FFC                107          MOVE.L  A7,STACK    ; store original location of stack beforehand
0000187A  4FF8 2FFC                108          LEA     STACK,A7
0000187E  48E7 FFFE                109          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to restore them
00001882                           110  
00001882                           111  ** Populate exception vector table ***
00001882  21FC 000020B6 0008       112          MOVE.L  #BERR,$8
0000188A  21FC 000020A0 000C       113          MOVE.L  #ADDRERR,$C
00001892  21FC 000020CC 0010       114          MOVE.L  #ILLINS,$10
0000189A  21FC 000020E4 0014       115          MOVE.L  #DIV0,$14
000018A2  21FC 000020F0 0018       116          MOVE.L  #CHKERR,$18
000018AA  21FC 000020D8 0020       117          MOVE.L  #PRIVERR,$20
000018B2  21FC 000020FC 0028       118          MOVE.L  #LINEA,$28
000018BA  21FC 00002108 002C       119          MOVE.L  #LINEF,$2C
000018C2                           120          
000018C2                           121  *** MAIN: Prompt, execute and repeat ***
000018C2  43F8 1000                122          LEA     WELCOME,A1
000018C6  103C 000D                123          MOVE.B  #13,D0
000018CA  4E4F                     124          TRAP    #15     ; display welcome message
000018CC  9FFC 00000050            125          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input (do only once)
000018D2  43F8 105A                126  PROMPT  LEA     PROMPT_STR,A1  
000018D6  103C 000E                127          MOVE.B  #14,D0
000018DA  4E4F                     128          TRAP    #15     ; print out prompt
000018DC  224F                     129          MOVEA.L A7,A1   ; input will go in stack
000018DE  103C 0002                130          MOVE.B  #2,D0
000018E2  4E4F                     131          TRAP    #15     ; read user input, length stored in D1
000018E4                           132          
000018E4  49F8 1095                133          LEA     COM_TABL,A4 ; beginning of command table
000018E8  4BF8 10E2                134          LEA     COM_ADDR,A5 ; end of command table
000018EC  4283                     135          CLR.L   D3      ; will be the count of where the command is
000018EE  4282                     136  SEARCH  CLR.L   D2
000018F0  141C                     137          MOVE.B  (A4)+,D2   ; length of next command string
000018F2  0402 0030                138          SUBI.B  #$30,D2 ; convert ascii num to hex
000018F6  2C49                     139          MOVEA.L A1,A6   ; pointer to input string
000018F8  BD0C                     140  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
000018FA  56CA FFFC                141          DBNE    D2,CMP_B    ; keep comparing characters until length is over
000018FE  4A42                     142          TST.W   D2
00001900  6D00 0010                143          BLT     EXEC    ; loop was exhausted and all chars were equal
00001904  D9C2                     144          ADDA.L  D2,A4   ; go to end of command
00001906  5483                     145          ADDQ.L  #2,D3   ; else, increment offset by word size
00001908  BBCC                     146          CMPA.L  A4,A5 ; end of COM_TABL
0000190A  6CE2                     147          BGE     SEARCH  ; keep on searching
0000190C                           148          
0000190C  6100 0686                149          BSR     INVALID ; print invalid command message
00001910  60C0                     150          BRA     PROMPT ; prompt again
00001912                           151          
00001912  DBC3                     152  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
00001914  267C 00000000            153          MOVEA.L #0,A3   ; clear A3, used for subroutine call
0000191A  3655                     154          MOVEA.W (A5),A3 ; move that command's address to register
0000191C  4E93                     155          JSR     (A3)    ; jump to that command's subroutine (below)
0000191E                           156  
0000191E  60B2                     157          BRA     PROMPT  ; prompt again
00001920                           158  
00001920                           159  *** DEBUGGING COMMANDS ***
00001920                           160  * HELP -- displays help message
00001920  48E7 C040                161  HELP    MOVEM.L D0-D1/A1,-(A7) ; store used registers in stack
00001924  43F8 10FE                162          LEA     HELP_MSG,A1  
00001928  103C 000D                163          MOVE.B  #13,D0
0000192C  4E4F                     164          TRAP    #15     ; print first part of the help message
0000192E  103C 0005                165          MOVE.B  #5,D0
00001932  4E4F                     166          TRAP    #15     ; wait for the user to enter a character
00001934  43F8 1442                167          LEA     HELP_MSG2,A1
00001938  103C 000D                168          MOVE.B  #13,D0
0000193C  4E4F                     169          TRAP    #15     ; print second half of the message
0000193E  4CDF 0203                170          MOVEM.L (A7)+,D0-D1/A1 ; restore registers from stack
00001942  4E75                     171          RTS
00001944                           172          
00001944                           173  * For this subroutine and others, A6 contains the start of the command's parameters
00001944                           174  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
00001944                           175  
00001944                           176  * MDSP -- displays memory block
00001944  48E7 F878                177  MDSP    MOVEM.L D0-D4/A1-A4,-(A7)
00001948  121E                     178          MOVE.B  (A6)+,D1    ; first '$'
0000194A  0C01 0024                179          CMPI.B  #$24,D1 ; is it '$'?
0000194E  6600 0068                180          BNE     MDSPINV ; wrong command usage
00001952  6100 0654                181          BSR     MEM2HEX ; D1 has 1st address in hex
00001956  2441                     182          MOVEA.L D1,A2   ;store in A2
00001958  121E                     183          MOVE.B  (A6)+,D1    ; space in between addresses
0000195A  4A01                     184          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
0000195C  6600 000E                185          BNE     MDSPADDR2
00001960  264A                     186          MOVEA.L A2,A3
00001962  D7FC 00000010            187          ADDA.L  #16,A3  ; A3 = A2 +16
00001968  6000 0012                188          BRA     MDSPLOOP
0000196C  121E                     189  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
0000196E  0C01 0024                190          CMPI.B  #$24,D1
00001972  6600 0044                191          BNE     MDSPINV
00001976  6100 0630                192          BSR     MEM2HEX ; D1 has 2nd address in hex
0000197A  2641                     193          MOVEA.L D1,A3
0000197C  224F                     194  MDSPLOOP    MOVEA.L A7,A1
0000197E  93FC 00000040            195          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
00001984  133C 0000                196          MOVE.B  #$00,-(A1) ; null terminator
00001988  133C 0020                197          MOVE.B  #$20,-(A1)  ; space
0000198C  133C 003E                198          MOVE.B  #$3E,-(A1)  ; '>' for nicer output
00001990  220A                     199          MOVE.L  A2,D1   ; memory address into D1
00001992  6100 0650                200          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
00001996  133C 0024                201          MOVE.B  #$24,-(A1)  ; '$' for nicer output
0000199A  103C 000E                202          MOVE.B  #14,D0
0000199E  4E4F                     203          TRAP    #15     ; print current memory address
000019A0  133C 0000                204          MOVE.B  #$00,-(A1)  ; null terminator
000019A4  221A                     205          MOVE.L  (A2)+,D1    ; memory value into D1
000019A6  6100 063C                206          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
000019AA  103C 000D                207          MOVE.B  #13,D0
000019AE  4E4F                     208          TRAP    #15     ; print
000019B0  B7CA                     209          CMPA.L  A2,A3
000019B2  6EC8                     210          BGT     MDSPLOOP
000019B4  6000 0006                211          BRA     MDSPDONE
000019B8  6100 05DA                212  MDSPINV BSR     INVALID ; print invalid command message
000019BC  4CDF 1E1F                213  MDSPDONE    MOVEM.L (A7)+,D0-D4/A1-A4
000019C0  4E75                     214          RTS
000019C2                           215  
000019C2                           216  * SORTW -- implements bubble sort (unsigned numbers)
000019C2  48E7 F878                217  SORTW   MOVEM.L D0-D4/A1-A4,-(A7)
000019C6  121E                     218          MOVE.B  (A6)+,D1    ; first '$'
000019C8  0C01 0024                219          CMPI.B  #$24,D1     ; is it '$'?
000019CC  6600 0072                220          BNE     SORTWINV    ; wrong command usage
000019D0  6100 05D6                221          BSR     MEM2HEX     ; D1 has 1st address in hex
000019D4  2441                     222          MOVEA.L D1,A2       ; store in A2
000019D6  121E                     223          MOVE.B  (A6)+,D1    ; space in between addresses
000019D8  0C01 0020                224          CMPI.B  #$20,D1     ; is it ' '?
000019DC  6600 0062                225          BNE     SORTWINV    ; wrong command usage
000019E0  121E                     226          MOVE.B  (A6)+,D1    ; second '$'
000019E2  0C01 0024                227          CMPI.B  #$24,D1     ; is it '$'?
000019E6  6600 0058                228          BNE     SORTWINV    ; wrong command usage
000019EA  6100 05BC                229          BSR     MEM2HEX     ; D1 has now the 2nd address
000019EE  2641                     230          MOVEA.L D1,A3       ; store in A3
000019F0  121E                     231          MOVE.B  (A6)+,D1    ; space 
000019F2  0C01 0000                232          CMPI.B  #$00,D1     ; is it NULL?
000019F6  6700 001C                233          BEQ     SORTWDEF    ; use default: descending (D1=0)
000019FA  0C01 0020                234          CMPI.B  #$20,D1     ; or is it ' '?
000019FE  6600 0040                235          BNE     SORTWINV    ; wrong command usage
00001A02  121E                     236          MOVE.B  (A6)+,D1    ; char either 'A' or 'D'
00001A04  0C01 0041                237          CMPI.B  #$41,D1     ; is it 'A'?
00001A08  6700 000C                238          BEQ     SORTWLOOP   ; if so, D1 marks ascending
00001A0C  0C01 0044                239          CMPI.B  #$44,D1     ; else, is it 'D'?
00001A10  6600 002E                240          BNE     SORTWINV    ; if it isn't, input was invalid
00001A14  4281                     241  SORTWDEF    CLR.L   D1          ; if it is, D1=0 marks descending
00001A16  284A                     242  SORTWLOOP   MOVEA.L A2,A4   ; first address copied into A4
00001A18  4A01                     243  SORTWCMP    TST.B   D1      ; tells us whether ascending or descending
00001A1A  6700 000C                244          BEQ     SORTWD  ; do descending
00001A1E  B94C                     245  SORTWA  CMP.W   (A4)+,(A4)+ ; compare next two numbers
00001A20  6500 0016                246          BCS     SORTWSWAP   ; swap if not in ascending order (if 1st>2nd)
00001A24  6000 0008                247          BRA     SORTWNEXT   ; otherwise, move on
00001A28  B94C                     248  SORTWD  CMP.W   (A4)+,(A4)+ ; compare next two numbers
00001A2A  6200 000C                249          BHI     SORTWSWAP   ; swap if not in descending order (if 2nd>1st)
00001A2E  558C                     250  SORTWNEXT   SUBQ.L  #2,A4   ; look back at previous number
00001A30  B7CC                     251          CMP.L   A4,A3       
00001A32  66E4                     252          BNE     SORTWCMP    ; keep comparing if not at end yet (A3 inclusive)
00001A34  6000 000E                253          BRA     SORTWDONE   ; else, done
00001A38  2824                     254  SORTWSWAP MOVE.L  -(A4),D4   ; move both words to register
00001A3A  4844                     255          SWAP.W  D4  ; swap the two words 
00001A3C  2884                     256          MOVE.L  D4,(A4) ; write them back
00001A3E  60D6                     257          BRA     SORTWLOOP   ; loop again from start
00001A40  6100 0552                258  SORTWINV    BSR INVALID
00001A44  4CDF 1E1F                259  SORTWDONE   MOVEM.L (A7)+,D0-D4/A1-A4
00001A48  4E75                     260          RTS
00001A4A                           261  
00001A4A                           262  * MM -- modifies data in memory. Size can be B, W or L
00001A4A  48E7 C0C0                263  MM      MOVEM.L D0-D1/A0-A1,-(A7)
00001A4E  224E                     264          MOVEA.L A6,A1   ; A1 used for I/O later
00001A50  121E                     265          MOVE.B  (A6)+,D1    ; '$'
00001A52  0C01 0024                266          CMPI.B  #$24,D1 ; is it '$'?
00001A56  6600 053C                267          BNE     INVALID ; wrong command usage
00001A5A  6100 054C                268          BSR     MEM2HEX ; D1 has address in hex
00001A5E  2041                     269          MOVEA.L D1,A0   ;store in A0
00001A60  121E                     270          MOVE.B  (A6)+,D1    ; ' ' before option
00001A62  0C01 0000                271          CMPI.B  #0,D1       ; is it null?
00001A66  6700 0028                272          BEQ     MMBYTE  ; use default: byte
00001A6A  0C01 0020                273          CMPI.B  #$20,D1 ; is it ' '?
00001A6E  6600 0524                274          BNE     INVALID ; wrong command usage
00001A72  121E                     275          MOVE.B  (A6)+,D1    ; the option
00001A74  0C01 0042                276          CMPI.B  #'B',D1
00001A78  6700 0016                277          BEQ     MMBYTE
00001A7C  0C01 0057                278          CMPI.B  #'W',D1
00001A80  6700 005E                279          BEQ     MMWORD
00001A84  0C01 004C                280          CMPI.B  #'L',D1
00001A88  6700 00A6                281          BEQ     MMLONG
00001A8C  6000 00F0                282          BRA     MMINV   ; wrong option
00001A90  D3FC 0000000E            283  MMBYTE  ADDA.L  #14,A1  ; output will be 13 chars long + null
00001A96  133C 0000                284          MOVE.B  #0,-(A1)    ; null terminator
00001A9A  133C 003F                285          MOVE.B  #'?',-(A1)  ; nicer output
00001A9E  4281                     286          CLR.L   D1
00001AA0  1210                     287          MOVE.B  (A0),D1     ; content of memory to D1
00001AA2  6100 0540                288          BSR     HEX2MEM     ; writes memory content to -8(A1)
00001AA6  5C89                     289          ADDA.L  #6,A1       ; we only want 2 chars, not 8
00001AA8  133C 0009                290          MOVE.B  #$9,-(A1)   ; a tabspace
00001AAC  2208                     291          MOVE.L  A0,D1       ; memory address
00001AAE  6100 0534                292          BSR     HEX2MEM     ; memory address to -8(A1)
00001AB2  133C 0024                293          MOVE.B  #'$',-(A1)  ; nicer output
00001AB6  103C 000E                294          MOVE.B  #14,D0
00001ABA  4E4F                     295          TRAP    #15         ; print
00001ABC  103C 0002                296          MOVE.B  #2,D0
00001AC0  4E4F                     297          TRAP    #15         ; read new value, if any
00001AC2  0C11 0000                298          CMPI.B  #0,(A1)
00001AC6  6600 0006                299          BNE     MMBNEXT     ; skip memory address?
00001ACA  5288                     300          ADDA.L  #1,A0       ; if yes, increment A0
00001ACC  60C2                     301          BRA     MMBYTE      ; ...and loop
00001ACE  0C11 002E                302  MMBNEXT CMPI.B  #'.',(A1)   ; else, check if done (entered '.')
00001AD2  6700 00AE                303          BEQ     MMDONE
00001AD6  2C49                     304          MOVEA.L A1,A6       ; new value to write in!
00001AD8  6100 04CE                305          BSR     MEM2HEX     ; store input value from A6 in D1
00001ADC  10C1                     306          MOVE.B  D1,(A0)+    ; put it in address location
00001ADE  60B0                     307          BRA     MMBYTE      ; and loop!
00001AE0  D3FC 00000010            308  MMWORD  ADDA.L  #16,A1  ; output will be 15 chars long + null
00001AE6  133C 0000                309          MOVE.B  #0,-(A1)
00001AEA  133C 003F                310          MOVE.B  #'?',-(A1)
00001AEE  4281                     311          CLR.L   D1
00001AF0  3210                     312          MOVE.W  (A0),D1
00001AF2  6100 04F0                313          BSR     HEX2MEM     ; writes memory content to -8(A1)
00001AF6  5889                     314          ADDA.L  #4,A1       ; we only want 4 chars, not 8
00001AF8  133C 0009                315          MOVE.B  #$9,-(A1)   ; a tabspace
00001AFC  2208                     316          MOVE.L  A0,D1
00001AFE  6100 04E4                317          BSR     HEX2MEM     ; memory address to -8(A1)
00001B02  133C 0024                318          MOVE.B  #'$',-(A1)
00001B06  103C 000E                319          MOVE.B  #14,D0
00001B0A  4E4F                     320          TRAP    #15         ; print
00001B0C  103C 0002                321          MOVE.B  #2,D0
00001B10  4E4F                     322          TRAP    #15         ; read new value, if any
00001B12  0C11 0000                323          CMPI.B  #0,(A1)
00001B16  6600 0006                324          BNE     MMWNEXT     ; skip memory address?
00001B1A  5488                     325          ADDA.L  #2,A0       ; if yes, increment A0
00001B1C  60C2                     326          BRA     MMWORD      ; ...and loop
00001B1E  0C11 002E                327  MMWNEXT CMPI.B  #'.',(A1)   ; else, check if done (entered '.')
00001B22  6700 005E                328          BEQ     MMDONE
00001B26  2C49                     329          MOVEA.L A1,A6       ; new value to write in!
00001B28  6100 047E                330          BSR     MEM2HEX     ; store input value from A6 in D1
00001B2C  30C1                     331          MOVE.W  D1,(A0)+    ; put it in address location
00001B2E  60B0                     332          BRA     MMWORD      ; and loop!
00001B30  D3FC 00000014            333  MMLONG  ADDA.L  #20,A1  ; output will be 19 chars long + null
00001B36  133C 0000                334          MOVE.B  #0,-(A1)
00001B3A  133C 003F                335          MOVE.B  #'?',-(A1)
00001B3E  4281                     336          CLR.L   D1
00001B40  2210                     337          MOVE.L  (A0),D1
00001B42  6100 04A0                338          BSR     HEX2MEM     ; writes memory content to -8(A1)
00001B46  133C 0009                339          MOVE.B  #$9,-(A1)   ; a tabspace
00001B4A  2208                     340          MOVE.L  A0,D1
00001B4C  6100 0496                341          BSR     HEX2MEM     ; memory address to -8(A1)
00001B50  133C 0024                342          MOVE.B  #'$',-(A1)
00001B54  103C 000E                343          MOVE.B  #14,D0
00001B58  4E4F                     344          TRAP    #15         ; print
00001B5A  103C 0002                345          MOVE.B  #2,D0
00001B5E  4E4F                     346          TRAP    #15         ; read new value, if any
00001B60  0C11 0000                347          CMPI.B  #0,(A1)
00001B64  6600 0006                348          BNE     MMLNEXT     ; skip memory address?
00001B68  5888                     349          ADDA.L  #4,A0       ; if yes, increment A0
00001B6A  60C4                     350          BRA     MMLONG      ; ...and loop
00001B6C  0C11 002E                351  MMLNEXT CMPI.B  #'.',(A1)   ; else, check if done (entered '.')
00001B70  6700 0010                352          BEQ     MMDONE
00001B74  2C49                     353          MOVEA.L A1,A6       ; new value to write in!
00001B76  6100 0430                354          BSR     MEM2HEX     ; store input value from A6 in D1
00001B7A  20C1                     355          MOVE.L  D1,(A0)+    ; put it in address location
00001B7C  60B2                     356          BRA     MMLONG      ; and loop!
00001B7E  6100 0414                357  MMINV   BSR     INVALID
00001B82  4CDF 0303                358  MMDONE  MOVEM.L (A7)+,D0-D1/A0-A1
00001B86  4E75                     359          RTS
00001B88                           360          
00001B88                           361  * MS -- store ascii (including null terminator) or hex in memory
00001B88  48E7 4040                362  MS      MOVEM.L D1/A1,-(A7)
00001B8C  121E                     363          MOVE.B  (A6)+,D1    ; first '$'
00001B8E  0C01 0024                364          CMPI.B  #$24,D1     ; is it '$'?
00001B92  6600 005C                365          BNE     MSINV    ; wrong command usage
00001B96  6100 0410                366          BSR     MEM2HEX     ; D1 has 1st address in hex
00001B9A  2241                     367          MOVEA.L D1,A1       ; store in A1
00001B9C  121E                     368          MOVE.B  (A6)+,D1
00001B9E  0C01 0020                369          CMPI.B  #$20,D1     ; is it ' '?
00001BA2  6600 004C                370          BNE     MSINV   ; wrong command usage
00001BA6  121E                     371          MOVE.B  (A6)+,D1
00001BA8  0C01 0024                372          CMPI.B  #$24,D1     ; '$'?
00001BAC  6700 0010                373          BEQ     MSHEX
00001BB0  538E                     374          SUBA.L  #1,A6   ; have to put A6 back at start of ascii
00001BB2  12D6                     375  MSASCII MOVE.B  (A6),(A1)+  ; put that char in (A1) and increment A1
00001BB4  0C1E 0000                376          CMPI.B  #0,(A6)+    ; check if end and increment A6 to match A1
00001BB8  6700 003A                377          BEQ     MSDONE  ; end of string
00001BBC  60F4                     378          BRA     MSASCII ; repeat
00001BBE  6100 03E8                379  MSHEX   BSR     MEM2HEX ; hex number stored in D1
00001BC2  0C81 000000FF            380          CMPI.L  #$FF,D1 ; see size of number
00001BC8  6F00 0020                381          BLE     MSBYTE
00001BCC  0C81 0000FFFF            382          CMPI.L  #$FFFF,D1
00001BD2  6F00 000E                383          BLE     MSWORD
00001BD6  5889                     384  MSLONG  ADDA.L  #4,A1   ; move A1 to end of long word
00001BD8  1301                     385          MOVE.B  D1,-(A1)    ; have to copy 4 bytes
00001BDA  E099                     386          ROR.L   #8,D1       ; first one was copied, so look at next byte
00001BDC  1301                     387          MOVE.B  D1,-(A1)    ; copy second byte
00001BDE  E099                     388          ROR.L   #8,D1
00001BE0  5589                     389          SUBA.L  #2,A1   ; done to counteract the next action
00001BE2  5489                     390  MSWORD  ADDA.L  #2,A1   ; move A1 to end of word
00001BE4  1301                     391          MOVE.B  D1,-(A1)    ; will copy 2 bytes
00001BE6  E099                     392          ROR.L   #8,D1   ; look at second one
00001BE8  5389                     393          SUBA.L  #1,A1   ; to counteract the fact that MSBYTE doesn't predecrement
00001BEA  1281                     394  MSBYTE  MOVE.B  D1,(A1) ; copy one byte
00001BEC  6000 0006                395          BRA     MSDONE
00001BF0  6100 03A2                396  MSINV   BSR     INVALID
00001BF4  4CDF 0202                397  MSDONE  MOVEM.L (A7)+,D1/A1
00001BF8  4E75                     398          RTS
00001BFA                           399  
00001BFA                           400  * BF -- fills block of memory with word pattern
00001BFA  48E7 F170                401  BF      MOVEM.L D0-D3/D7/A1-A3,-(A7)
00001BFE  121E                     402          MOVE.B  (A6)+,D1    ; first '$'
00001C00  0C01 0024                403          CMPI.B  #$24,D1 ; is it '$'?
00001C04  6600 0058                404          BNE     BFINV ; wrong command usage
00001C08  6100 039E                405          BSR     MEM2HEX ; D1 has 1st address in hex
00001C0C  2441                     406          MOVEA.L D1,A2   ;store in A2
00001C0E  121E                     407          MOVE.B  (A6)+,D1    ; space in between addresses
00001C10  0C01 0020                408          CMPI.B  #$20,D1 ; is it ' '?
00001C14  6600 0048                409          BNE     BFINV
00001C18  121E                     410          MOVE.B  (A6)+,D1    ; second '$'
00001C1A  0C01 0024                411          CMPI.B  #$24,D1
00001C1E  6600 003E                412          BNE     BFINV   
00001C22  6100 0384                413          BSR     MEM2HEX ; D1 has 2nd address in hex
00001C26  2641                     414          MOVEA.L D1,A3   ; both addresses have been read now
00001C28  4282                     415          CLR.L   D2      ; pattern will go in here
00001C2A  121E                     416          MOVE.B  (A6)+,D1    ; space before the pattern
00001C2C  0C01 0000                417          CMPI.B  #$00,D1 ; no pattern given, use default
00001C30  6700 0020                418          BEQ     BFSTART
00001C34  0C01 0020                419          CMPI.B  #$20,D1 ; is it ' '?
00001C38  6600 0024                420          BNE     BFINV
00001C3C  7603                     421          MOVE.L  #3,D3   ; counter for remaining 3 digits (if there)
00001C3E  1E1E                     422  BFPATT  MOVE.B  (A6)+,D7    ; first byte of pattern
00001C40  4A07                     423          TST.B   D7
00001C42  6700 000E                424          BEQ     BFSTART ; only one digit was given, use first one padded with a zero
00001C46  E982                     425          ASL.L   #4,D2   ; place first digit on the left part of the byte
00001C48  6100 038A                426          BSR     ASCII2NUM
00001C4C  D407                     427          ADD.B   D7,D2   ; goes into the right part of the byte
00001C4E  51CB FFEE                428          DBF     D3,BFPATT   ; debrease D3 and keep looping until all digits read
00001C52  3613                     429  BFSTART MOVE.W  (A3),D3 ; TEST: if address2 not even, address error is raised
00001C54  B7CA                     430  BFLOOP  CMPA.L  A2,A3
00001C56  6F00 000A                431          BLE     BFDONE  ; done when A2 reaches A3
00001C5A  34C2                     432          MOVE.W  D2,(A2)+    ; write the pattern in memory. Address error raised if address1 not even
00001C5C  60F6                     433          BRA     BFLOOP
00001C5E  6100 0334                434  BFINV   BSR     INVALID
00001C62  4CDF 0E8F                435  BFDONE  MOVEM.L (A7)+,D0-D3/D7/A1-A3
00001C66  4E75                     436          RTS
00001C68                           437          
00001C68                           438  * BMOV -- copies block of memory somewhere else
00001C68  48E7 4038                439  BMOV    MOVEM.L D1/A2-A4,-(A7)
00001C6C  121E                     440          MOVE.B  (A6)+,D1    ; first '$'
00001C6E  0C01 0024                441          CMPI.B  #$24,D1 ; is it '$'?
00001C72  6600 0046                442          BNE     BMINV ; wrong command usage
00001C76  6100 0330                443          BSR     MEM2HEX ; D1 has 1st address in hex
00001C7A  2441                     444          MOVEA.L D1,A2   ;store in A2
00001C7C  121E                     445          MOVE.B  (A6)+,D1    ; space in between addresses
00001C7E  0C01 0020                446          CMPI.B  #$20,D1 ; is it ' '?
00001C82  6600 0036                447          BNE     BMINV
00001C86  121E                     448          MOVE.B  (A6)+,D1    ; second '$'
00001C88  0C01 0024                449          CMPI.B  #$24,D1
00001C8C  6600 002C                450          BNE     BMINV   
00001C90  6100 0316                451          BSR     MEM2HEX ; D1 has 2nd address in hex
00001C94  2641                     452          MOVE.L  D1,A3   ; store in A3
00001C96  121E                     453          MOVE.B  (A6)+,D1    ; space in between addresses
00001C98  0C01 0020                454          CMPI.B  #$20,D1 ; is it ' '?
00001C9C  6600 001C                455          BNE     BMINV
00001CA0  121E                     456          MOVE.B  (A6)+,D1    ; third '$'
00001CA2  0C01 0024                457          CMPI.B  #$24,D1
00001CA6  6600 0012                458          BNE     BMINV   
00001CAA  6100 02FC                459          BSR     MEM2HEX ; D1 has 3rd address in hex
00001CAE  2841                     460          MOVE.L  D1,A4       ; store in A4
00001CB0  B7CA                     461  BMLOOP  CMPA.L  A2,A3
00001CB2  6F00 000A                462          BLE     BMDONE  ; done when A2 reaches A3
00001CB6  18DA                     463          MOVE.B  (A2)+,(A4)+ ; copy
00001CB8  60F6                     464          BRA     BMLOOP
00001CBA  6100 02D8                465  BMINV   BSR     INVALID
00001CBE  4CDF 1C02                466  BMDONE  MOVEM.L (A7)+,D1/A2-A4
00001CC2  4E75                     467          RTS
00001CC4                           468          
00001CC4                           469  * BTST -- tests each bit (by setting and unsetting all) in a block of memory
00001CC4= 4D 45 4D 4F 52 59 ...    470  BTERROR DC.B    'MEMORY ERROR FOUND AT LOCATION $00000000'
00001CEC= 0A 0D                    471  BTLOC   DC.B    $A,$D ; this and BTREAD point after for HEX2MEM to work
00001CEE= 56 61 6C 75 65 20 ...    472          DC.B    'Value expected: '
00001CFE= 30 30 0A 0D              473  BTEXP   DC.B    '00',$A,$D
00001D02= 56 61 6C 75 65 20 ...    474          DC.B    'Value read: 00'
00001D10= 00                       475  BTREAD  DC.B    0
00001D12  48E7 C070                476  BTST    MOVEM.L D0-D1/A1-A3,-(A7)
00001D16  121E                     477          MOVE.B  (A6)+,D1    ; first '$'
00001D18  0C01 0024                478          CMPI.B  #$24,D1 ; is it '$'?
00001D1C  6600 00A8                479          BNE     BTINV ; wrong command usage
00001D20  6100 0286                480          BSR     MEM2HEX ; D1 has 1st address in hex
00001D24  2441                     481          MOVEA.L D1,A2   ; store in A2
00001D26  224A                     482          MOVEA.L A2,A1   ; store copy for BTLOOP2
00001D28  121E                     483          MOVE.B  (A6)+,D1    ; space in between addresses
00001D2A  0C01 0020                484          CMPI.B  #$20,D1 ; is it ' '?
00001D2E  6600 0096                485          BNE     BTINV
00001D32  121E                     486          MOVE.B  (A6)+,D1    ; second '$'
00001D34  0C01 0024                487          CMPI.B  #$24,D1
00001D38  6600 008C                488          BNE     BTINV   
00001D3C  6100 026A                489          BSR     MEM2HEX ; D1 has 2nd address in hex
00001D40  2641                     490          MOVE.L  D1,A3   ; store in A3
00001D42  4281                     491          CLR.L   D1  ; needed to only look at bytes
00001D44  B7CA                     492  BTLOOP1 CMPA.L  A2,A3   ; this loop tries bit pattern 1010
00001D46  6F00 003C                493          BLE     BTPRELOOP2
00001D4A  14BC 00AA                494          MOVE.B  #$AA,(A2)   ; write
00001D4E  121A                     495          MOVE.B  (A2)+,D1    ; read
00001D50  0C01 00AA                496          CMPI.B  #$AA,D1     ; check correct
00001D54  67EE                     497          BEQ     BTLOOP1     ; move to next byte
00001D56  43F8 1D10                498          LEA     BTREAD,A1   ; if here, there is a problem in memory!
00001D5A  6100 02B0                499          BSR     HEX2MEM_NOZ ; load everything to memory, to be able to print error
00001D5E  43F8 1CFE                500          LEA     BTEXP,A1
00001D62  12FC 0041                501          MOVE.B  #'A',(A1)+
00001D66  12BC 0041                502          MOVE.B  #'A',(A1)
00001D6A  43F8 1CEC                503          LEA     BTLOC,A1
00001D6E  538A                     504          SUBA.L  #1,A2
00001D70  220A                     505          MOVE.L  A2,D1
00001D72  6100 0270                506          BSR     HEX2MEM
00001D76  43F8 1CC4                507          LEA     BTERROR,A1
00001D7A  103C 000D                508          MOVE.B  #13,D0
00001D7E  4E4F                     509          TRAP    #15     ; print the error message
00001D80  6000 0048                510          BRA     BTDONE  ; stop execution
00001D84  2449                     511  BTPRELOOP2  MOVEA.L A1,A2   ; copy was stored a while back to be able to start over
00001D86  B7CA                     512  BTLOOP2 CMPA.L  A2,A3   ; this loop tries bit pattern 0101. Works the same as BTLOOP1
00001D88  6F00 0040                513          BLE     BTDONE
00001D8C  14BC 0055                514          MOVE.B  #$55,(A2)   ; write
00001D90  121A                     515          MOVE.B  (A2)+,D1    ; read
00001D92  0C01 0055                516          CMPI.B  #$55,D1     ; check correct
00001D96  67EE                     517          BEQ     BTLOOP2     ; move to next byte
00001D98  43F8 1D10                518          LEA     BTREAD,A1   ; error in memory, act like before
00001D9C  6100 026E                519          BSR     HEX2MEM_NOZ
00001DA0  43F8 1CFE                520          LEA     BTEXP,A1
00001DA4  12FC 0035                521          MOVE.B  #'5',(A1)+
00001DA8  12BC 0035                522          MOVE.B  #'5',(A1)
00001DAC  43F8 1CEC                523          LEA     BTLOC,A1
00001DB0  538A                     524          SUBA.L  #1,A2
00001DB2  220A                     525          MOVE.L  A2,D1
00001DB4  6100 022E                526          BSR     HEX2MEM
00001DB8  43F8 1CC4                527          LEA     BTERROR,A1
00001DBC  103C 000D                528          MOVE.B  #13,D0
00001DC0  4E4F                     529          TRAP    #15
00001DC2  6000 0006                530          BRA     BTDONE
00001DC6  6100 01CC                531  BTINV   BSR     INVALID
00001DCA  4CDF 0E03                532  BTDONE  MOVEM.L (A7)+,D0-D1/A1-A3
00001DCE  4E75                     533          RTS
00001DD0                           534          
00001DD0                           535  * BSCH -- search for string literal in memory block
00001DD0= 4E 6F 74 20 66 6F ...    536  BSNO        DC.B    'Not found',0
00001DDA= 46 6F 75 6E 64 20 ...    537  BSYES       DC.B    'Found at location: $00000000'
00001DF6= 00                       538  BSYESADDR   DC.B 0
00001DF8  48E7 4040                539  BSCH    MOVEM.L D1/A1,-(A7)
00001DFC  43F8 1DD0                540          LEA     BSNO,A1 ; will change if found
00001E00  121E                     541          MOVE.B  (A6)+,D1    ; first '$'
00001E02  0C01 0024                542          CMPI.B  #'$',D1 ; is it '$'?
00001E06  6600 0048                543          BNE     BSINV   ; wrong command usage
00001E0A  6100 019C                544          BSR     MEM2HEX ; D1 has 1st address in hex
00001E0E  2441                     545          MOVEA.L D1,A2   ; store in A2
00001E10  121E                     546          MOVE.B  (A6)+,D1    ; space in between addresses
00001E12  0C01 0020                547          CMPI.B  #' ',D1 ; is it ' '?
00001E16  6600 0038                548          BNE     BSINV
00001E1A  121E                     549          MOVE.B  (A6)+,D1    ; second '$'
00001E1C  0C01 0024                550          CMPI.B  #'$',D1
00001E20  6600 002E                551          BNE     BSINV   
00001E24  6100 0182                552          BSR     MEM2HEX ; D1 has 2nd address in hex
00001E28  2641                     553          MOVE.L  D1,A3   ; store in A3
00001E2A  121E                     554          MOVE.B  (A6)+,D1    ; a space
00001E2C  0C01 0020                555          CMPI.B  #' ',D1
00001E30  6600 001E                556          BNE     BSINV
00001E34  B7CA                     557  BSLOOP  CMPA.L A2,A3
00001E36  6700 0030                558          BEQ     BSDONE  ; stop if A2 reaches A3 (not found)
00001E3A  284E                     559          MOVEA.L A6,A4   ; keep A6 for reference
00001E3C  B90A                     560          CMP.B   (A2)+,(A4)+ ; compare first char
00001E3E  66F4                     561          BNE     BSLOOP  ; look at next if different
00001E40  2A4A                     562          MOVE.L  A2,A5   ; keep A2 for reference
00001E42  0C14 0000                563  BSMAYB  CMPI.B  #0,(A4) ; see if we reached end of string
00001E46  6700 0010                564          BEQ     BSFOUND ; if we did, the whole string matched!
00001E4A  B90D                     565          CMP.B   (A5)+,(A4)+ ; else, compare next char
00001E4C  66E6                     566          BNE     BSLOOP  ; if not equal, have to check next possible word start
00001E4E  60F2                     567          BRA     BSMAYB  ; if equal, keep on looking in this word
00001E50  6100 0142                568  BSINV   BSR     INVALID
00001E54  6000 0018                569          BRA     BSEND
00001E58  220A                     570  BSFOUND MOVE.L  A2,D1   ; to tell where it was found
00001E5A  5381                     571          SUBQ.L  #1,D1   ; was off by one
00001E5C  43F8 1DF6                572          LEA     BSYESADDR,A1
00001E60  6100 0182                573          BSR     HEX2MEM ; write address in the message
00001E64  43F8 1DDA                574          LEA     BSYES,A1
00001E68  103C 000D                575  BSDONE  MOVE.B  #13,D0
00001E6C  4E4F                     576          TRAP    #15     ; print message: found or not found
00001E6E  4CDF 0202                577  BSEND   MOVEM.L (A7)+,D1/A1
00001E72  4E75                     578          RTS
00001E74                           579          
00001E74                           580  * GO -- executes another program
00001E74  48E7 FFFF                581  GO      MOVEM.L D0-D7/A0-A7,-(A7)   ; don't allow the program to change registers
00001E78  121E                     582          MOVE.B  (A6)+,D1    ; '$'
00001E7A  0C01 0024                583          CMPI.B  #$24,D1 ; is it '$'?
00001E7E  6600 000E                584          BNE     GOINV   ; wrong command usage
00001E82  6100 0124                585          BSR     MEM2HEX ; D1 has address in hex
00001E86  2041                     586          MOVEA.L D1,A0   ;store in A0
00001E88  4E90                     587          JSR     (A0)    ; execute the program
00001E8A  6000 0006                588          BRA     GODONE
00001E8E  6100 0104                589  GOINV   BSR     INVALID
00001E92  4CDF FFFF                590  GODONE  MOVEM.L (A7)+,D0-D7/A0-A7
00001E96  4E75                     591          RTS
00001E98                           592          
00001E98                           593  * DF -- displays formatted registers
00001E98  48E7 E0C0                594  DF      MOVEM.L D0-D2/A0-A1,-(A7)
00001E9C  41F8 2FFC                595          LEA     STACK,A0
00001EA0  5888                     596          ADDA.L  #4,A0   ; placed after A7 in stack
00001EA2  43F8 17BE                597          LEA     DF_MSG_END,A1
00001EA6  5389                     598  DFLOOP  SUBQ.L  #1,A1   ; pass the $A at end of each line
00001EA8  7403                     599          MOVE.L  #3,D2   ; number of registers per line - 1
00001EAA  2220                     600  DFLINE  MOVE.L  -(A0),D1    ; put register value in D1
00001EAC  6100 0136                601          BSR     HEX2MEM     ; will store D1 in -8(A1)
00001EB0  5989                     602          SUBQ.L  #4,A1   ; skip other characters
00001EB2  51CA FFF6                603          DBF     D2,DFLINE   ; keep looping till line done       
00001EB6  B3FC 000016FB            604          CMP.L   #DF_MSG,A1
00001EBC  6EE8                     605          BGT     DFLOOP
00001EBE  5289                     606          ADDQ.L  #1,A1   ; put back at the front of the message
00001EC0  103C 000D                607          MOVE.B  #13,D0
00001EC4  4E4F                     608          TRAP    #15     ; print register value
00001EC6  4CDF 0307                609          MOVEM.L (A7)+,D0-D2/A0-A1
00001ECA  4E75                     610          RTS
00001ECC                           611  
00001ECC                           612  * EXIT -- terminates the program
00001ECC  43F8 102C                613  EXIT    LEA     GOODBYE,A1
00001ED0  103C 000D                614          MOVE.B  #13,D0
00001ED4  4E4F                     615          TRAP    #15     ; print goodbye message
00001ED6  588F                     616          ADDA.L  #4,A7   ; move past the PC stored in the stack
00001ED8  DFFC 00000050            617          ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input
00001EDE  4CDF 7FFF                618          MOVEM.L (A7)+,D0-D7/A0-A6   ; restore all registers in stack
00001EE2  2E78 2FFC                619          MOVEA.L STACK,A7
00001EE6  6000 212C                620          BRA     END     ; exit program
00001EEA                           621          
00001EEA                           622  * The 2 extra commands:
00001EEA                           623  * BPRINT -- print as ascii a memory block
00001EEA  48E7 C070                624  BPRINT  MOVEM.L D0-D1/A1-A3,-(A7)
00001EEE  121E                     625          MOVE.B  (A6)+,D1    ; first '$'
00001EF0  0C01 0024                626          CMPI.B  #'$',D1 ; is it '$'?
00001EF4  6600 005C                627          BNE     BPINV ; wrong command usage
00001EF8  6100 00AE                628          BSR     MEM2HEX ; D1 has 1st address in hex
00001EFC  2441                     629          MOVEA.L D1,A2   ; store in A2
00001EFE  121E                     630          MOVE.B  (A6)+,D1    ; space in between addresses
00001F00  0C01 0000                631          CMPI.B  #0,D1   ; is it null?
00001F04  6700 0040                632          BEQ     BPNULL  ; read until null character found
00001F08  0C01 0020                633          CMPI.B  #' ',D1 ; is it ' '?
00001F0C  6600 0044                634          BNE     BPINV
00001F10  121E                     635          MOVE.B  (A6)+,D1    ; second '$'
00001F12  0C01 0024                636          CMPI.B  #'$',D1
00001F16  6600 003A                637          BNE     BPINV   
00001F1A  6100 008C                638          BSR     MEM2HEX ; D1 has 2nd address in hex
00001F1E  2641                     639          MOVE.L  D1,A3   ; store in A3
00001F20  224E                     640          MOVEA.L A6,A1   ; print from here
00001F22  137C 0000 0001           641          MOVE.B  #0,1(A1)    ; make sure
00001F28  103C 000E                642          MOVE.B  #14,D0  ; for printing trap
00001F2C  B7CA                     643  BPBLOCK CMPA.L  A2,A3
00001F2E  6F00 0008                644          BLE     BPBDONE ; stop when A2 reaches A3
00001F32  129A                     645          MOVE.B  (A2)+,(A1)  ; put byte in (A1)
00001F34  4E4F                     646          TRAP    #15 ; print that byte!
00001F36  60F4                     647          BRA     BPBLOCK
00001F38  12BC 0000                648  BPBDONE MOVE.B  #0,(A1)
00001F3C  103C 000D                649          MOVE.B  #13,D0
00001F40  4E4F                     650          TRAP    #15     ; print a line feed and carriage return
00001F42  6000 0012                651          BRA     BPDONE
00001F46  224A                     652  BPNULL  MOVEA.L A2,A1   ; no limit given, so print till null char found
00001F48  103C 000D                653          MOVE.B  #13,D0
00001F4C  4E4F                     654          TRAP    #15     ; print!
00001F4E  6000 0006                655          BRA     BPDONE
00001F52  6100 0040                656  BPINV   BSR     INVALID  
00001F56  4CDF 0E03                657  BPDONE  MOVEM.L (A7)+,D0-D1/A1-A3
00001F5A  4E75                     658          RTS
00001F5C                           659  
00001F5C                           660  * CONV -- takes in hex and returns decimal, or viceversa
00001F5C  48E7 C040                661  CONV    MOVEM.L D0-D1/A1,-(A7)
00001F60  121E                     662          MOVE.B  (A6)+,D1
00001F62  0C01 0024                663          CMPI.B  #$24,D1 ; is it '$'?
00001F66  6700 0016                664          BEQ     CONVH2D ; if so, hex to dec
00001F6A  538E                     665  CONVD2H SUBQ.L  #1,A6   ; point back at first number
00001F6C  6100 00E2                666          BSR     MEM2DEC ; D1 contains the decimal number
00001F70  224E                     667          MOVEA.L A6,A1   ; number ready to print
00001F72  6100 0098                668          BSR     HEX2MEM_NOZ ; that number is written as hex in memory
00001F76  133C 0024                669          MOVE.B  #'$',-(A1)
00001F7A  6000 000C                670          BRA     CONVDONE
00001F7E  6100 0028                671  CONVH2D BSR     MEM2HEX ; convert ascii to hex
00001F82  224E                     672          MOVEA.L A6,A1   ;number ready to print
00001F84  6100 00F8                673          BSR     DEC2MEM ; convert it back to ascii but as decimal
00001F88  103C 000D                674  CONVDONE MOVE.B #13,D0
00001F8C  4E4F                     675          TRAP    #15 ; print result
00001F8E  4CDF 0203                676          MOVEM.L (A7)+,D0-D1/A1
00001F92  4E75                     677          RTS
00001F94                           678  
00001F94                           679  *** HELPERS ***
00001F94                           680  * Print INVALID message:
00001F94  48E7 8040                681  INVALID MOVEM.L D0/A1,-(A7)
00001F98  43F8 1068                682          LEA     INVALID_MSG,A1  ; command was invalid
00001F9C  103C 000D                683          MOVE.B  #13,D0
00001FA0  4E4F                     684          TRAP    #15     ; output invalid command
00001FA2  4CDF 0201                685          MOVEM.L (A7)+,D0/A1
00001FA6  4E75                     686          RTS
00001FA8                           687  
00001FA8                           688  * Takes X digits from (A6) in ascii and puts them in D1 as hex:
00001FA8  48E7 8100                689  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
00001FAC  4281                     690          CLR.L   D1
00001FAE  1E1E                     691          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001FB0  0C07 0030                692          CMPI.B  #$30,D7
00001FB4  6D00 0016                693          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001FB8  6100 001A                694  M2HNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
00001FBC  D207                     695          ADD.B   D7,D1
00001FBE  1E1E                     696          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001FC0  0C07 0030                697          CMPI.B  #$30,D7
00001FC4  6D00 0006                698          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001FC8  E981                     699          ASL.L   #4,D1   ; skip this the last time
00001FCA  60EC                     700          BRA     M2HNEXT ; loop again because not done
00001FCC  538E                     701  M2HDONE SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
00001FCE  4CDF 0081                702          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001FD2  4E75                     703          RTS
00001FD4                           704  
00001FD4                           705  * Takes byte in ascii in D7 and converts it to digit in D7:
00001FD4                           706  * Assumes 0-9 or A-F
00001FD4  0C07 0040                707  ASCII2NUM   CMPI.B #$40,D7
00001FD8  6D00 0004                708          BLT A2NSKIPPY
00001FDC  5F07                     709          SUBQ.B  #$7,D7   ; only for A-F
00001FDE  0407 0030                710  A2NSKIPPY   SUB.B   #$30,D7
00001FE2  4E75                     711          RTS
00001FE4                           712          
00001FE4                           713  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001FE4  48E7 A100                714  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001FE8  4280                     715          CLR.L   D0   ; counter
00001FEA  2E01                     716  H2MNEXT MOVE.L  D1,D7
00001FEC  2400                     717          MOVE.L D0,D2
00001FEE  5342                     718  H2MRIGHT    SUBQ.W  #1,D2
00001FF0  6D00 0006                719          BLT     H2MDONE
00001FF4  E88F                     720          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001FF6  60F6                     721          BRA     H2MRIGHT
00001FF8  6100 0040                722  H2MDONE BSR     NUM2ASCII   ; convert to ascii in D7
00001FFC  1307                     723          MOVE.B  D7,-(A1)
00001FFE  5240                     724          ADDQ.W  #1,D0
00002000  0C40 0008                725          CMPI.W  #8,D0
00002004  6DE4                     726          BLT     H2MNEXT
00002006  4CDF 0085                727          MOVEM.L (A7)+,D0/D2/D7
0000200A  4E75                     728          RTS
0000200C                           729          
0000200C                           730  * Takes X digits from D1 in hex and puts them into -X(A1) in ascii (no trailing zeros):
0000200C  48E7 A100                731  HEX2MEM_NOZ MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00002010  4280                     732          CLR.L   D0   ; counter
00002012  2E01                     733  H2MZNEXT MOVE.L  D1,D7
00002014  2400                     734          MOVE.L D0,D2
00002016  5342                     735  H2MZRIGHT    SUBQ.W  #1,D2
00002018  6D00 0006                736          BLT     H2MZDONE
0000201C  E88F                     737          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
0000201E  60F6                     738          BRA     H2MZRIGHT
00002020  4A87                     739  H2MZDONE TST.L   D7
00002022  6700 0010                740          BEQ     H2MZEND      ; if number done
00002026  6100 0012                741          BSR     NUM2ASCII   ; convert to ascii in D7
0000202A  1307                     742          MOVE.B  D7,-(A1)
0000202C  5240                     743          ADDQ.W  #1,D0
0000202E  0C40 0008                744          CMPI.W  #8,D0
00002032  6DDE                     745          BLT     H2MZNEXT
00002034  4CDF 0085                746  H2MZEND  MOVEM.L (A7)+,D0/D2/D7
00002038  4E75                     747          RTS
0000203A                           748  
0000203A                           749  * Takes digit in D7 and converts it to ascii byte in D7:
0000203A                           750  * Assumes 0-9 or A-F
0000203A  CEBC 0000000F            751  NUM2ASCII   AND.L  #$0F,D7 ; mask and take only smallest hex digit
00002040  0C07 000A                752          CMPI.B  #$A,D7
00002044  6D00 0004                753          BLT N2ASKIPPY
00002048  5E07                     754          ADDQ.B  #$7,D7   ; only for A-F
0000204A  0607 0030                755  N2ASKIPPY   ADD.B   #$30,D7
0000204E  4E75                     756          RTS
00002050                           757          
00002050                           758  * Takes X digits from (A6) in ascii and puts them in D1 as dec:
00002050  48E7 8100                759  MEM2DEC MOVEM.L D0/D7,-(A7)    ; store in stack
00002054  4281                     760          CLR.L   D1
00002056  1E1E                     761          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00002058  0C07 0030                762          CMPI.B  #$30,D7
0000205C  6D00 0018                763          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
00002060  6100 FF72                764  M2DNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
00002064  D207                     765          ADD.B   D7,D1
00002066  1E1E                     766          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00002068  0C07 0030                767          CMPI.B  #$30,D7
0000206C  6D00 0008                768          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
00002070  C2FC 000A                769          MULU    #10,D1   ; skip this the last time
00002074  60EA                     770          BRA     M2DNEXT ; loop again because not done
00002076  538E                     771  M2DDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
00002078  4CDF 0081                772          MOVEM.L (A7)+,D0/D7    ; restore from stack
0000207C  4E75                     773          RTS
0000207E                           774  
0000207E                           775  * Takes number from D1 in dec and puts them into -X(A1) in ascii:
0000207E  48E7 2100                776  DEC2MEM MOVEM.L D2/D7,-(A7)    ; store in stack
00002082  2401                     777          MOVE.L  D1,D2
00002084  84FC 000A                778  D2MLOOP DIVU    #10,D2
00002088  2E02                     779          MOVE.L  D2,D7
0000208A  4847                     780          SWAP.W  D7
0000208C  61AC                     781          BSR     NUM2ASCII
0000208E  1307                     782          MOVE.B  D7,-(A1)
00002090  C4BC 0000FFFF            783          AND.L   #$0000FFFF,D2 ; make sure we use only word in next divisions
00002096  4A42                     784          TST.W   D2
00002098  66EA                     785          BNE     D2MLOOP
0000209A  4CDF 0084                786          MOVEM.L (A7)+,D2/D7
0000209E  4E75                     787          RTS
000020A0                           788          
000020A0                           789  *** EXCEPTION HANDLERS ***
000020A0  48E7 8040                790  ADDRERR MOVEM.L D0/A1,-(A7)
000020A4  48E7 4080                791          MOVEM.L D1/A0,-(A7) ; specific for this interrupt
000020A8  43F8 17BE                792          LEA     ADDRERR_MSG,A1
000020AC  103C 000D                793          MOVE.B  #13,D0
000020B0  4E4F                     794          TRAP    #15
000020B2  6000 0060                795          BRA     INTERR_REG  ; print the special registers
000020B6  48E7 8040                796  BERR    MOVEM.L D0/A1,-(A7)
000020BA  48E7 4080                797          MOVEM.L D1/A0,-(A7) ; specific for this interrupt
000020BE  43F8 17D7                798          LEA     BERR_MSG,A1
000020C2  103C 000D                799          MOVE.B  #13,D0
000020C6  4E4F                     800          TRAP    #15
000020C8  6000 004A                801          BRA     INTERR_REG  ; print the special registers
000020CC  48E7 8040                802  ILLINS  MOVEM.L D0/A1,-(A7)
000020D0  43F8 17EC                803          LEA     ILLINS_MSG,A1
000020D4  6000 007C                804          BRA     INTERR 
000020D8  48E7 8040                805  PRIVERR MOVEM.L D0/A1,-(A7)
000020DC  43F8 180A                806          LEA     PRIVERR_MSG,A1
000020E0  6000 0070                807          BRA     INTERR 
000020E4  48E7 8040                808  DIV0    MOVEM.L D0/A1,-(A7)
000020E8  43F8 1825                809          LEA     DIV0_MSG,A1
000020EC  6000 0064                810          BRA     INTERR 
000020F0  48E7 8040                811  CHKERR  MOVEM.L D0/A1,-(A7)
000020F4  43F8 1841                812          LEA     CHKERR_MSG,A1
000020F8  6000 0058                813          BRA     INTERR 
000020FC  48E7 8040                814  LINEA   MOVEM.L D0/A1,-(A7)
00002100  43F8 1852                815          LEA     LINEA_MSG,A1
00002104  6000 004C                816          BRA     INTERR 
00002108  48E7 8040                817  LINEF   MOVEM.L D0/A1,-(A7)
0000210C  43F8 1864                818          LEA     LINEF_MSG,A1
00002110  6000 0040                819          BRA     INTERR
00002114                           820  INTERR_REG  ; only BERR and ADDRERR do this
00002114  204F                     821          MOVEA.L A7,A0
00002116  D1FC 00000018            822          ADDA.L  #24,A0  ; A0 is pointing right below SSW, BA and IR
0000211C  227C 00002FFC            823          MOVEA.L #STACK,A1
00002122  93FC 0000003C            824          SUBA.L  #60,A1  ; write message in the input space of the stack (currently unused)
00002128  133C 0000                825          MOVE.B  #0,-(A1)    ; null terminator
0000212C  4281                     826          CLR.L   D1
0000212E  3220                     827          MOVE.W  -(A0),D1    ; SSW in D1
00002130  6100 FEB2                828          BSR     HEX2MEM
00002134  5889                     829          ADDQ.L  #4,A1       ; only want SSW to be a word
00002136  133C 0020                830          MOVE.B  #' ',-(A1)
0000213A  2220                     831          MOVE.L  -(A0),D1    ; BA in D1
0000213C  6100 FEA6                832          BSR     HEX2MEM
00002140  133C 0020                833          MOVE.B  #' ',-(A1)
00002144  4281                     834          CLR.L   D1
00002146  3220                     835          MOVE.W  -(A0),D1    ; IR in D1
00002148  6100 FE9A                836          BSR     HEX2MEM
0000214C  5889                     837          ADDQ.L  #4,A1       ; only want IR to be a word
0000214E  4CDF 0102                838          MOVEM.L (A7)+,D1/A0 ; restore these specific registers
00002152  103C 000D                839  INTERR  MOVE.B  #13,D0
00002156  4E4F                     840          TRAP    #15 ; print corresponding message for that interrupt
00002158  6100 FD3E                841          BSR     DF  ; print registers
0000215C  4CDF 0201                842          MOVEM.L (A7)+,D0/A1 ; do here to be able to modify values of A7
00002160  4FF8 2FFC                843          LEA     STACK,A7    ; next 3 instructions put A7 at beginning of input space in stack
00002164  9FFC 0000003C            844          SUBA.L  #60,A7  ; 15 registers that occupy 4 bytes each (2*4 = 8 bits)
0000216A  9FFC 00000050            845          SUBA.L  #MAX_IN_LEN,A7  ; the input space
00002170  6000 F760                846          BRA     PROMPT
00002174                           847          
00002174                           848  *** PROGRAM FOR TESTING GO ***    
00004000                           849      ORG $4000
00004000  227C 00004020            850          MOVEA.L #$4020,A1
00004006  22BC 48492100            851          MOVE.L  #$48492100,(A1)
0000400C  103C 000D                852          MOVE.B  #13,D0
00004010  4E4F                     853          TRAP    #15     ; print secret message
00004012  4E75                     854          RTS
00004014                           855  
00004014                           856  END
00004014                           857      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2NSKIPPY           1FDE
ADDRERR             20A0
ADDRERR_MSG         17BE
ASCII2NUM           1FD4
BERR                20B6
BERR_MSG            17D7
BF                  1BFA
BFDONE              1C62
BFINV               1C5E
BFLOOP              1C54
BFPATT              1C3E
BFSTART             1C52
BMDONE              1CBE
BMINV               1CBA
BMLOOP              1CB0
BMOV                1C68
BPBDONE             1F38
BPBLOCK             1F2C
BPDONE              1F56
BPINV               1F52
BPNULL              1F46
BPRINT              1EEA
BSCH                1DF8
BSDONE              1E68
BSEND               1E6E
BSFOUND             1E58
BSINV               1E50
BSLOOP              1E34
BSMAYB              1E42
BSNO                1DD0
BSYES               1DDA
BSYESADDR           1DF6
BTDONE              1DCA
BTERROR             1CC4
BTEXP               1CFE
BTINV               1DC6
BTLOC               1CEC
BTLOOP1             1D44
BTLOOP2             1D86
BTPRELOOP2          1D84
BTREAD              1D10
BTST                1D12
CHKERR              20F0
CHKERR_MSG          1841
CMP_B               18F8
COM_ADDR            10E2
COM_TABL            1095
CONV                1F5C
CONVD2H             1F6A
CONVDONE            1F88
CONVH2D             1F7E
D2MLOOP             2084
DEC2MEM             207E
DF                  1E98
DFLINE              1EAA
DFLOOP              1EA6
DF_MSG              16FB
DF_MSG_END          17BE
DIV0                20E4
DIV0_MSG            1825
END                 4014
EXEC                1912
EXIT                1ECC
GO                  1E74
GODONE              1E92
GOINV               1E8E
GOODBYE             102C
H2MDONE             1FF8
H2MNEXT             1FEA
H2MRIGHT            1FEE
H2MZDONE            2020
H2MZEND             2034
H2MZNEXT            2012
H2MZRIGHT           2016
HELP                1920
HELP_MSG            10FE
HELP_MSG2           1442
HEX2MEM             1FE4
HEX2MEM_NOZ         200C
ILLINS              20CC
ILLINS_MSG          17EC
INTERR              2152
INTERR_REG          2114
INVALID             1F94
INVALID_MSG         1068
LINEA               20FC
LINEA_MSG           1852
LINEF               2108
LINEF_MSG           1864
M2DDONE             2076
M2DNEXT             2060
M2HDONE             1FCC
M2HNEXT             1FB8
MAX_IN_LEN          50
MDSP                1944
MDSPADDR2           196C
MDSPDONE            19BC
MDSPINV             19B8
MDSPLOOP            197C
MEM2DEC             2050
MEM2HEX             1FA8
MM                  1A4A
MMBNEXT             1ACE
MMBYTE              1A90
MMDONE              1B82
MMINV               1B7E
MMLNEXT             1B6C
MMLONG              1B30
MMWNEXT             1B1E
MMWORD              1AE0
MS                  1B88
MSASCII             1BB2
MSBYTE              1BEA
MSDONE              1BF4
MSHEX               1BBE
MSINV               1BF0
MSLONG              1BD6
MSWORD              1BE2
N2ASKIPPY           204A
NUM2ASCII           203A
PRIVERR             20D8
PRIVERR_MSG         180A
PROMPT              18D2
PROMPT_STR          105A
SEARCH              18EE
SORTW               19C2
SORTWA              1A1E
SORTWCMP            1A18
SORTWD              1A28
SORTWDEF            1A14
SORTWDONE           1A44
SORTWINV            1A40
SORTWLOOP           1A16
SORTWNEXT           1A2E
SORTWSWAP           1A38
STACK               2FFC
START               1876
WELCOME             1000

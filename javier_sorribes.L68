000011D4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/6/2017 00:49:42

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 0A 0D 4D 4F 4E 49 ...     11  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
0000103A= 49 4E 56 41 4C 49 ...     12  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
0000104B= 54 79 70 65 20 48 ...     13              DC.B    'Type HELP for command usage',0
00001067                            14  
00001067= 34 48 45 4C 50 00         15  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000106D= 34 4D 44 53 50 20         16              DC.B    '4MDSP',$20  ; number specifies length of word 
00001073= 32 4D 4D 00               17              DC.B    '2MM',0       ; used for SEARCH (not input)
00001077= 34 45 58 49 54 00         18              DC.B    '4EXIT',0
0000107D                            19              
0000107E= 1242                      20  COM_ADDR    DC.W    HELP        ; Command addresses table
00001080= 1256                      21              DC.W    MDSP
00001082= 12D8                      22              DC.W    MM
00001084= 12DA                      23              DC.W    EXIT
00001086                            24              
00001086= 48 45 4C 50 3A 20 ...     25  HELP_MSG    DC.B    'HELP: Displays this message',$A,$A,$D
000010A4= 4D 44 53 50 3A 20 ...     26              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
000010CF= 44 65 66 61 75 6C ...     27              DC.B    'Default address2: address1 + 16',$A,$D
000010F0= 4D 44 53 50 20 3C ...     28              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
00001126= 4D 4D 3A 20 4D 6F ...     29              DC.B    'MM: Modifies Data In Memory',$A,$D
00001143= 44 65 66 61 75 6C ...     30              DC.B    'Default: Displays one byte',$A,$D
0000115F= 3B 57 3A 20 44 69 ...     31              DC.B    ';W: Displays One Word',$A,$D
00001176= 3B 4C 3A 20 44 69 ...     32              DC.B    ';L: Displays One Long Word',$A,$D
00001192= 4D 4D 20 3C 61 64 ...     33              DC.B    'MM <address>[;size]',$A,$A,$D
000011A8                            34              ** Add all others as I go
000011A8= 45 58 49 54 3A 20 ...     35              DC.B    'EXIT: Exit the monitor program eg: EXIT<CR>',0
000011D4                            36              
000011D4                            37  *** RUNNING PROGRAM ***
000011D4                            38      ;ORG     $1200
000011D4                            39  START:                  ; first instruction of program
000011D4                            40  
000011D4  =00000050                 41  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
000011D4  =00003000                 42  STACK       EQU $3000
000011D4  4FF8 3000                 43          LEA     STACK,A7
000011D8  48E7 FFFE                 44          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to display them
000011DC                            45  
000011DC                            46          **Populate exception vector table
000011DC                            47          
000011DC                            48  *** MAIN: Prompt, execute and repeat ***
000011DC  43F8 1000                 49          LEA     WELCOME,A1
000011E0  103C 000D                 50          MOVE.B  #13,D0
000011E4  4E4F                      51          TRAP    #15
000011E6  43F8 102C                 52  PROMPT  LEA     PROMPT_STR,A1  
000011EA  103C 000E                 53          MOVE.B  #14,D0
000011EE  4E4F                      54          TRAP    #15     ; print out prompt
000011F0  9FFC 00000050             55          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input -- COULD GO BEFORE PROMPT (REF #1)
000011F6  224F                      56          MOVEA.L A7,A1   ; input will go in stack
000011F8  103C 0002                 57          MOVE.B  #2,D0
000011FC  4E4F                      58          TRAP    #15     ; read user input, length stored in D1
000011FE                            59          
000011FE  49F8 1067                 60          LEA     COM_TABL,A4 ; beginning of command table
00001202  4BF8 107E                 61          LEA     COM_ADDR,A5 ; end of command table
00001206  4283                      62          CLR.L   D3      ; will be the count of where the command is
00001208  4282                      63  SEARCH  CLR.L   D2
0000120A  141C                      64          MOVE.B  (A4)+,D2   ; length of next command string
0000120C  0402 0030                 65          SUBI.B  #$30,D2 ; convert ascii num to hex
00001210  2C49                      66          MOVEA.L A1,A6   ; pointer to input string
00001212  BD0C                      67  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
00001214  56CA FFFC                 68          DBNE    D2,CMP_B    ; keep comparing characters until length is over
00001218  4A42                      69          TST.W   D2
0000121A  6D00 0012                 70          BLT     EXEC    ; loop was exhausted and all chars were equal
0000121E  D9C2                      71          ADDA.L  D2,A4   ; go to end of command
00001220  5483                      72          ADDQ.L  #2,D3   ; else, increment offset by word size
00001222  BBCC                      73          CMPA.L  A4,A5 ; end of COM_TABL
00001224  6CE2                      74          BGE     SEARCH  ; keep on searching
00001226                            75          
00001226  6100 00B8                 76          BSR     INVALID ; print invalid command message
0000122A  6000 000E                 77          BRA     ENDLOOP ; prompt again
0000122E                            78          
0000122E  DBC3                      79  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
00001230  267C 00000000             80          MOVEA.L #0,A3   ; clear A3, used for subroutine call
00001236  3655                      81          MOVEA.W (A5),A3 ; move that command's address to register
00001238  4E93                      82          JSR     (A3)    ; jump to that command's subroutine (below)
0000123A                            83  
0000123A  DFFC 00000050             84  ENDLOOP ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input -- COULD GO IN EXIT SUBROUTINE (REF #1)
00001240  60A4                      85          BRA     PROMPT  ; prompt again
00001242                            86  
00001242                            87  *** DEBUGGING COMMANDS ***
00001242  48E7 8040                 88  HELP    MOVEM.L D0/A1,-(A7) ; store used registers in stack
00001246  43F8 1086                 89          LEA     HELP_MSG,A1  
0000124A  103C 000D                 90          MOVE.B  #13,D0
0000124E  4E4F                      91          TRAP    #15     ; print help message
00001250  4CDF 0201                 92          MOVEM.L (A7)+,D0/A1 ; restore registers from stack
00001254  4E75                      93          RTS
00001256                            94          
00001256                            95  * For this subroutine and others, A6 contains the start of the command's parameters
00001256                            96  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
00001256  48E7 F070                 97  MDSP    MOVEM.L D0-D3/A1-A3,-(A7)
0000125A  121E                      98          MOVE.B  (A6)+,D1    ; first '$'
0000125C  0C01 0024                 99          CMPI.B  #$24,D1
00001260  6600 006C                100          BNE     MDSPINV ; wrong command usage
00001264  6100 008E                101          BSR     MEM2HEX ; D1 has 1st address in hex
00001268  2441                     102          MOVEA.L D1,A2
0000126A  121E                     103          MOVE.B  (A6)+,D1    ; space in between addresses
0000126C  4A01                     104          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
0000126E  6600 000E                105          BNE     MDSPADDR2
00001272  264A                     106          MOVEA.L A2,A3
00001274  D7FC 00000010            107          ADDA.L  #16,A3  ; A3 = A2 +16
0000127A  6000 0012                108          BRA     MDSPLOOP
0000127E  121E                     109  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
00001280  0C01 0024                110          CMPI.B  #$24,D1
00001284  6600 0048                111          BNE     MDSPINV
00001288  6100 006A                112          BSR     MEM2HEX ; D1 has 2nd address in hex
0000128C  2641                     113          MOVEA.L D1,A3
0000128E  224F                     114  MDSPLOOP    MOVEA.L A7,A1
00001290  93FC 00000040            115          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
00001296  133C 0000                116          MOVE.B  #$00,-(A1) ; null terminator
0000129A  133C 0020                117          MOVE.B  #$20,-(A1)  ; space
0000129E  133C 003E                118          MOVE.B  #$3E,-(A1)  ; '<' for nicer output
000012A2  220A                     119          MOVE.L  A2,D1
000012A4  6100 008A                120          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
000012A8  133C 0024                121          MOVE.B  #$24,-(A1)  ; '$' for nicer output
000012AC  103C 000E                122          MOVE.B  #14,D0
000012B0  4E4F                     123          TRAP    #15     ; print current memory address
000012B2  133C 0000                124          MOVE.B  #$00,-(A1) ; null terminator
000012B6  133C 0020                125          MOVE.B  #$20,-(A1)  ; space
000012BA  221A                     126          MOVE.L  (A2)+,D1
000012BC  6100 0072                127          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
000012C0  103C 000D                128          MOVE.B  #13,D0
000012C4  4E4F                     129          TRAP    #15
000012C6  B7CA                     130          CMPA.L  A2,A3
000012C8  6EC4                     131          BGT     MDSPLOOP
000012CA  6000 0006                132          BRA     MDSPDONE
000012CE  6100 0010                133  MDSPINV BSR     INVALID ; print invalid command message
000012D2  4CDF 0E0F                134  MDSPDONE    MOVEM.L (A7)+,D0-D3/A1-A3
000012D6  4E75                     135          RTS
000012D8                           136  
000012D8                           137  MM    
000012D8  4E75                     138          RTS
000012DA                           139  
000012DA  103C 0009                140  EXIT    MOVE.B  #9, D0
000012DE  4E4F                     141          TRAP    #15     ; exit program
000012E0                           142  
000012E0                           143  *** HELPERS ***
000012E0                           144  * Print INVALID message:
000012E0  48E7 8040                145  INVALID MOVEM.L D0/A1,-(A7)
000012E4  43F8 103A                146          LEA     INVALID_MSG,A1  ; command was invalid
000012E8  103C 000D                147          MOVE.B  #13,D0
000012EC  4E4F                     148          TRAP    #15     ; output invalid command
000012EE  4CDF 0201                149          MOVEM.L (A7)+,D0/A1
000012F2  4E75                     150          RTS
000012F4                           151  
000012F4                           152  * Takes 4 digits from (A6) in ascii and puts them in D1 as hex: -- COULD MAKE IT TAKE X DIGITS (REF #2)
000012F4  48E7 8100                153  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
000012F8  4281                     154          CLR.L   D1
000012FA  1E1E                     155          MOVE.B (A6)+,D7    ; read in next byte (prime read)
000012FC  0C07 0030                156          CMPI.B  #$30,D7
00001300  6D00 0016                157          BLT     MEM2HEXDONE ; reached some whitespace or non-numeric ascii
00001304  6100 001A                158  M2HNEXT BSR     BYTE2HEX    ; byte to hex digit, in D7
00001308  D207                     159          ADD.B   D7,D1
0000130A  1E1E                     160          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000130C  0C07 0030                161          CMPI.B  #$30,D7
00001310  6D00 0006                162          BLT     MEM2HEXDONE ; reached some whitespace or non-numeric ascii
00001314  E981                     163          ASL.L   #4,D1   ; skip this the last time
00001316  60EC                     164          BRA     M2HNEXT ; loop again because not done
00001318  538E                     165  MEM2HEXDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
0000131A  4CDF 0081                166          MOVEM.L (A7)+,D0/D7    ; restore from stack
0000131E  4E75                     167          RTS
00001320                           168  
00001320                           169  * Takes byte in ascii in D7 and converts it to hex in D7:
00001320                           170  * Assumes 0-9 or A-F
00001320  0C07 0040                171  BYTE2HEX CMPI.B #$40,D7
00001324  6D00 0004                172          BLT B2HSKIPPY
00001328  5F07                     173          SUBQ.B  #$7,D7   ; only for A-F
0000132A  0407 0030                174  B2HSKIPPY   SUB.B   #$30,D7
0000132E  4E75                     175          RTS
00001330                           176          
00001330                           177  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001330  48E7 A100                178  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001334  4280                     179          CLR.L   D0   ; counter
00001336  2E01                     180  H2MNEXT MOVE.L  D1,D7
00001338  2400                     181          MOVE.L D0,D2
0000133A  5342                     182  H2MRIGHT    SUBQ.W  #1,D2
0000133C  6D00 0006                183          BLT     H2MDONE
00001340  E88F                     184          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001342  60F6                     185          BRA     H2MRIGHT
00001344  6100 0012                186  H2MDONE BSR     HEX2BYTE ; convert to ascii in D7
00001348  1307                     187          MOVE.B  D7,-(A1)
0000134A  5240                     188          ADDQ.W  #1,D0
0000134C  0C40 0008                189          CMPI.W  #8,D0
00001350  6DE4                     190          BLT     H2MNEXT
00001352  4CDF 0085                191          MOVEM.L (A7)+,D0/D2/D7
00001356  4E75                     192          RTS
00001358                           193  
00001358                           194  * Takes hex digit in D7 and converts it to ascii byte in D7:
00001358                           195  * Assumes 0-9 or A-F
00001358  CEBC 0000000F            196  HEX2BYTE AND.L  #$0F,D7 ; mask and take only smallest hex digit
0000135E  0C07 000A                197          CMPI.B  #$A,D7
00001362  6D00 0004                198          BLT H2BSKIPPY
00001366  5E07                     199          ADDQ.B  #$7,D7   ; only for A-F
00001368  0607 0030                200  H2BSKIPPY   ADD.B   #$30,D7
0000136C  4E75                     201          RTS
0000136E                           202  
0000136E                           203      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B2HSKIPPY           132A
BYTE2HEX            1320
CMP_B               1212
COM_ADDR            107E
COM_TABL            1067
ENDLOOP             123A
EXEC                122E
EXIT                12DA
H2BSKIPPY           1368
H2MDONE             1344
H2MNEXT             1336
H2MRIGHT            133A
HELP                1242
HELP_MSG            1086
HEX2BYTE            1358
HEX2MEM             1330
INVALID             12E0
INVALID_MSG         103A
M2HNEXT             1304
MAX_IN_LEN          50
MDSP                1256
MDSPADDR2           127E
MDSPDONE            12D2
MDSPINV             12CE
MDSPLOOP            128E
MEM2HEX             12F4
MEM2HEXDONE         1318
MM                  12D8
PROMPT              11E6
PROMPT_STR          102C
SEARCH              1208
STACK               3000
START               11D4
WELCOME             1000

00001276 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/17/2017 21:52:10

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 0A 0D 4D 4F 4E 49 ...     11  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
0000103A= 49 4E 56 41 4C 49 ...     12  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
0000104B= 54 79 70 65 20 48 ...     13              DC.B    'Type HELP for command usage',0
00001067                            14  
00001067= 34 48 45 4C 50 00         15  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000106D= 34 4D 44 53 50 20         16              DC.B    '4MDSP',$20  ; number specifies length of word 
00001073= 35 53 4F 52 54 57 20      17              DC.B    '5SORTW',$20    ; used for SEARCH (not input)
0000107A= 32 4D 4D 00               18              DC.B    '2MM',0
0000107E= 34 45 58 49 54 00         19              DC.B    '4EXIT',0
00001084                            20              
00001084= 12E4                      21  COM_ADDR    DC.W    HELP        ; Command addresses table
00001086= 12F8                      22              DC.W    MDSP
00001088= 137A                      23              DC.W    SORTW
0000108A= 13FA                      24              DC.W    MM
0000108C= 13FC                      25              DC.W    EXIT
0000108E                            26              
0000108E= 48 45 4C 50 3A 20 ...     27  HELP_MSG    DC.B    'HELP: Displays this message',$A,$A,$D
000010AC= 4D 44 53 50 3A 20 ...     28              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
000010D7= 44 65 66 61 75 6C ...     29              DC.B    'Default address2: address1 + 16',$A,$D
000010F8= 4D 44 53 50 20 3C ...     30              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
0000112E= 53 4F 52 54 57 3A ...     31              DC.B    'SORTW: Sorts unsigned words in a block of memory',$A,$D
00001160= 42 6F 74 68 20 61 ...     32              DC.B    'Both address1 and address2 are inclusive',$A,$D
0000118A= 53 4F 52 54 57 20 ...     33              DC.B    'SORTW <address1> <address2> A|D eg: SORTW $2000 $201E A<CR>',$A,$A,$D
000011C8= 4D 4D 3A 20 4D 6F ...     34              DC.B    'MM: Modifies Data In Memory',$A,$D
000011E5= 44 65 66 61 75 6C ...     35              DC.B    'Default: Displays one byte',$A,$D
00001201= 3B 57 3A 20 44 69 ...     36              DC.B    ';W: Displays One Word',$A,$D
00001218= 3B 4C 3A 20 44 69 ...     37              DC.B    ';L: Displays One Long Word',$A,$D
00001234= 4D 4D 20 3C 61 64 ...     38              DC.B    'MM <address>[;size]',$A,$A,$D
0000124A                            39              ** Add all others as I go
0000124A= 45 58 49 54 3A 20 ...     40              DC.B    'EXIT: Exit the monitor program eg: EXIT<CR>',0
00001276                            41              
00001276                            42  *** RUNNING PROGRAM ***
00001276                            43      ;ORG     $1200
00001276                            44  START:                  ; first instruction of program
00001276                            45  
00001276  =00000050                 46  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
00001276  =00003000                 47  STACK       EQU $3000
00001276  4FF8 3000                 48          LEA     STACK,A7
0000127A  48E7 FFFE                 49          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to display them
0000127E                            50  
0000127E                            51          **Populate exception vector table
0000127E                            52          
0000127E                            53  *** MAIN: Prompt, execute and repeat ***
0000127E  43F8 1000                 54          LEA     WELCOME,A1
00001282  103C 000D                 55          MOVE.B  #13,D0
00001286  4E4F                      56          TRAP    #15     ; display welcome message
00001288  43F8 102C                 57  PROMPT  LEA     PROMPT_STR,A1  
0000128C  103C 000E                 58          MOVE.B  #14,D0
00001290  4E4F                      59          TRAP    #15     ; print out prompt
00001292  9FFC 00000050             60          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input
00001298  224F                      61          MOVEA.L A7,A1   ; input will go in stack
0000129A  103C 0002                 62          MOVE.B  #2,D0
0000129E  4E4F                      63          TRAP    #15     ; read user input, length stored in D1
000012A0                            64          
000012A0  49F8 1067                 65          LEA     COM_TABL,A4 ; beginning of command table
000012A4  4BF8 1084                 66          LEA     COM_ADDR,A5 ; end of command table
000012A8  4283                      67          CLR.L   D3      ; will be the count of where the command is
000012AA  4282                      68  SEARCH  CLR.L   D2
000012AC  141C                      69          MOVE.B  (A4)+,D2   ; length of next command string
000012AE  0402 0030                 70          SUBI.B  #$30,D2 ; convert ascii num to hex
000012B2  2C49                      71          MOVEA.L A1,A6   ; pointer to input string
000012B4  BD0C                      72  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
000012B6  56CA FFFC                 73          DBNE    D2,CMP_B    ; keep comparing characters until length is over
000012BA  4A42                      74          TST.W   D2
000012BC  6D00 0012                 75          BLT     EXEC    ; loop was exhausted and all chars were equal
000012C0  D9C2                      76          ADDA.L  D2,A4   ; go to end of command
000012C2  5483                      77          ADDQ.L  #2,D3   ; else, increment offset by word size
000012C4  BBCC                      78          CMPA.L  A4,A5 ; end of COM_TABL
000012C6  6CE2                      79          BGE     SEARCH  ; keep on searching
000012C8                            80          
000012C8  6100 0138                 81          BSR     INVALID ; print invalid command message
000012CC  6000 000E                 82          BRA     ENDLOOP ; prompt again
000012D0                            83          
000012D0  DBC3                      84  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
000012D2  267C 00000000             85          MOVEA.L #0,A3   ; clear A3, used for subroutine call
000012D8  3655                      86          MOVEA.W (A5),A3 ; move that command's address to register
000012DA  4E93                      87          JSR     (A3)    ; jump to that command's subroutine (below)
000012DC                            88  
000012DC  DFFC 00000050             89  ENDLOOP ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input
000012E2  60A4                      90          BRA     PROMPT  ; prompt again
000012E4                            91  
000012E4                            92  *** DEBUGGING COMMANDS ***
000012E4  48E7 8040                 93  HELP    MOVEM.L D0/A1,-(A7) ; store used registers in stack
000012E8  43F8 108E                 94          LEA     HELP_MSG,A1  
000012EC  103C 000D                 95          MOVE.B  #13,D0
000012F0  4E4F                      96          TRAP    #15     ; print help message
000012F2  4CDF 0201                 97          MOVEM.L (A7)+,D0/A1 ; restore registers from stack
000012F6  4E75                      98          RTS
000012F8                            99          
000012F8                           100  * For this subroutine and others, A6 contains the start of the command's parameters
000012F8                           101  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
000012F8  48E7 F070                102  MDSP    MOVEM.L D0-D3/A1-A3,-(A7)
000012FC  121E                     103          MOVE.B  (A6)+,D1    ; first '$'
000012FE  0C01 0024                104          CMPI.B  #$24,D1 ; is it '$'?
00001302  6600 006C                105          BNE     MDSPINV ; wrong command usage
00001306  6100 010E                106          BSR     MEM2HEX ; D1 has 1st address in hex
0000130A  2441                     107          MOVEA.L D1,A2   ;store in A2
0000130C  121E                     108          MOVE.B  (A6)+,D1    ; space in between addresses
0000130E  4A01                     109          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
00001310  6600 000E                110          BNE     MDSPADDR2
00001314  264A                     111          MOVEA.L A2,A3
00001316  D7FC 00000010            112          ADDA.L  #16,A3  ; A3 = A2 +16
0000131C  6000 0012                113          BRA     MDSPLOOP
00001320  121E                     114  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
00001322  0C01 0024                115          CMPI.B  #$24,D1
00001326  6600 0048                116          BNE     MDSPINV
0000132A  6100 00EA                117          BSR     MEM2HEX ; D1 has 2nd address in hex
0000132E  2641                     118          MOVEA.L D1,A3
00001330  224F                     119  MDSPLOOP    MOVEA.L A7,A1
00001332  93FC 00000040            120          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
00001338  133C 0000                121          MOVE.B  #$00,-(A1) ; null terminator
0000133C  133C 0020                122          MOVE.B  #$20,-(A1)  ; space
00001340  133C 003E                123          MOVE.B  #$3E,-(A1)  ; '<' for nicer output
00001344  220A                     124          MOVE.L  A2,D1
00001346  6100 010A                125          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
0000134A  133C 0024                126          MOVE.B  #$24,-(A1)  ; '$' for nicer output
0000134E  103C 000E                127          MOVE.B  #14,D0
00001352  4E4F                     128          TRAP    #15     ; print current memory address
00001354  133C 0000                129          MOVE.B  #$00,-(A1) ; null terminator
00001358  133C 0020                130          MOVE.B  #$20,-(A1)  ; space
0000135C  221A                     131          MOVE.L  (A2)+,D1
0000135E  6100 00F2                132          BSR     HEX2MEM ; puts digits of D1 into -8(A1) in ascii
00001362  103C 000D                133          MOVE.B  #13,D0
00001366  4E4F                     134          TRAP    #15
00001368  B7CA                     135          CMPA.L  A2,A3
0000136A  6EC4                     136          BGT     MDSPLOOP
0000136C  6000 0006                137          BRA     MDSPDONE
00001370  6100 0090                138  MDSPINV BSR     INVALID ; print invalid command message
00001374  4CDF 0E0F                139  MDSPDONE    MOVEM.L (A7)+,D0-D3/A1-A3
00001378  4E75                     140          RTS
0000137A                           141  
0000137A                           142  ; SORTW, implements bubble sort -- unsigned numbers
0000137A  48E7 F878                143  SORTW   MOVEM.L D0-D4/A1-A4,-(A7)
0000137E  121E                     144          MOVE.B  (A6)+,D1    ; first '$'
00001380  0C01 0024                145          CMPI.B  #$24,D1     ; is it '$'?
00001384  6600 006A                146          BNE     SORTWINV    ; wrong command usage
00001388  6100 008C                147          BSR     MEM2HEX     ; D1 has 1st address in hex
0000138C  2441                     148          MOVEA.L D1,A2       ; store in A2
0000138E  121E                     149          MOVE.B  (A6)+,D1    ; space in between addresses
00001390  0C01 0020                150          CMPI.B  #$20,D1     ; is it ' '?
00001394  6600 005A                151          BNE     SORTWINV    ; wrong command usage
00001398  121E                     152          MOVE.B  (A6)+,D1    ; second '$'
0000139A  0C01 0024                153          CMPI.B  #$24,D1     ; is it '$'?
0000139E  6600 0050                154          BNE     SORTWINV    ; wrong command usage
000013A2  6100 0072                155          BSR     MEM2HEX     ; D1 has now the 2nd address
000013A6  2641                     156          MOVEA.L D1,A3       ; store in A3
000013A8  121E                     157          MOVE.B  (A6)+,D1    ; space 
000013AA  0C01 0020                158          CMPI.B  #$20,D1     ; is it ' '?
000013AE  6600 0040                159          BNE     SORTWINV    ; wrong command usage
000013B2  121E                     160          MOVE.B  (A6)+,D1    ; char either 'A' or 'D'
000013B4  0C01 0041                161          CMPI.B  #$41,D1     ; is it 'A'?
000013B8  6700 000C                162          BEQ     SORTWLOOP   ; if so, D1 marks ascending
000013BC  0C01 0044                163          CMPI.B  #$44,D1     ; else, is it 'D'?
000013C0  6600 002E                164          BNE     SORTWINV    ; if it isn't, input was invalid
000013C4  4281                     165          CLR.L   D1          ; if it is, D1=0 marks descending
000013C6  284A                     166  SORTWLOOP   MOVEA.L A2,A4   ; first address copied into A4
000013C8  4A01                     167  SORTWCMP    TST.B   D1      ; tells us whether ascending or descending
000013CA  6700 000C                168          BEQ     SORTWD  ; do descending
000013CE  B94C                     169  SORTWA  CMP.W   (A4)+,(A4)+ ; compare next two numbers
000013D0  6500 0016                170          BCS     SORTWSWAP   ; swap if not in ascending order (if 1st>2nd)
000013D4  6000 0008                171          BRA     SORTWNEXT   ; otherwise, move on
000013D8  B94C                     172  SORTWD  CMP.W   (A4)+,(A4)+ ; compare next two numbers
000013DA  6200 000C                173          BHI     SORTWSWAP   ; swap if not in descending order (if 2nd>1st)
000013DE  558C                     174  SORTWNEXT   SUBQ.L  #2,A4   ; look back at previous number
000013E0  B7CC                     175          CMP.L   A4,A3       
000013E2  66E4                     176          BNE     SORTWCMP    ; keep comparing if not at end yet (A3 inclusive)
000013E4  6000 000E                177          BRA     SORTWDONE   ; else, done
000013E8  2824                     178  SORTWSWAP MOVE.L  -(A4),D4   ; move both words to register
000013EA  4844                     179          SWAP.W  D4  ; swap the two words 
000013EC  2884                     180          MOVE.L  D4,(A4) ; write them back
000013EE  60D6                     181          BRA     SORTWLOOP   ; loop again from start
000013F0  6100 0010                182  SORTWINV    BSR INVALID
000013F4  4CDF 1E1F                183  SORTWDONE   MOVEM.L (A7)+,D0-D4/A1-A4
000013F8  4E75                     184          RTS
000013FA                           185  
000013FA                           186  MM    
000013FA  4E75                     187          RTS
000013FC                           188  
000013FC  103C 0009                189  EXIT    MOVE.B  #9, D0
00001400  4E4F                     190          TRAP    #15     ; exit program
00001402                           191  
00001402                           192  *** HELPERS ***
00001402                           193  * Print INVALID message:
00001402  48E7 8040                194  INVALID MOVEM.L D0/A1,-(A7)
00001406  43F8 103A                195          LEA     INVALID_MSG,A1  ; command was invalid
0000140A  103C 000D                196          MOVE.B  #13,D0
0000140E  4E4F                     197          TRAP    #15     ; output invalid command
00001410  4CDF 0201                198          MOVEM.L (A7)+,D0/A1
00001414  4E75                     199          RTS
00001416                           200  
00001416                           201  * Takes X digits from (A6) in ascii and puts them in D1 as hex:
00001416  48E7 8100                202  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
0000141A  4281                     203          CLR.L   D1
0000141C  1E1E                     204          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000141E  0C07 0030                205          CMPI.B  #$30,D7
00001422  6D00 0016                206          BLT     MEM2HEXDONE ; reached some whitespace or non-numeric ascii
00001426  6100 001A                207  M2HNEXT BSR     BYTE2HEX    ; byte to hex digit, in D7
0000142A  D207                     208          ADD.B   D7,D1
0000142C  1E1E                     209          MOVE.B (A6)+,D7    ; read in next byte (prime read)
0000142E  0C07 0030                210          CMPI.B  #$30,D7
00001432  6D00 0006                211          BLT     MEM2HEXDONE ; reached some whitespace or non-numeric ascii
00001436  E981                     212          ASL.L   #4,D1   ; skip this the last time
00001438  60EC                     213          BRA     M2HNEXT ; loop again because not done
0000143A  538E                     214  MEM2HEXDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
0000143C  4CDF 0081                215          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001440  4E75                     216          RTS
00001442                           217  
00001442                           218  * Takes byte in ascii in D7 and converts it to hex in D7:
00001442                           219  * Assumes 0-9 or A-F
00001442  0C07 0040                220  BYTE2HEX CMPI.B #$40,D7
00001446  6D00 0004                221          BLT B2HSKIPPY
0000144A  5F07                     222          SUBQ.B  #$7,D7   ; only for A-F
0000144C  0407 0030                223  B2HSKIPPY   SUB.B   #$30,D7
00001450  4E75                     224          RTS
00001452                           225          
00001452                           226  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001452  48E7 A100                227  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001456  4280                     228          CLR.L   D0   ; counter
00001458  2E01                     229  H2MNEXT MOVE.L  D1,D7
0000145A  2400                     230          MOVE.L D0,D2
0000145C  5342                     231  H2MRIGHT    SUBQ.W  #1,D2
0000145E  6D00 0006                232          BLT     H2MDONE
00001462  E88F                     233          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001464  60F6                     234          BRA     H2MRIGHT
00001466  6100 0012                235  H2MDONE BSR     HEX2BYTE ; convert to ascii in D7
0000146A  1307                     236          MOVE.B  D7,-(A1)
0000146C  5240                     237          ADDQ.W  #1,D0
0000146E  0C40 0008                238          CMPI.W  #8,D0
00001472  6DE4                     239          BLT     H2MNEXT
00001474  4CDF 0085                240          MOVEM.L (A7)+,D0/D2/D7
00001478  4E75                     241          RTS
0000147A                           242  
0000147A                           243  * Takes hex digit in D7 and converts it to ascii byte in D7:
0000147A                           244  * Assumes 0-9 or A-F
0000147A  CEBC 0000000F            245  HEX2BYTE AND.L  #$0F,D7 ; mask and take only smallest hex digit
00001480  0C07 000A                246          CMPI.B  #$A,D7
00001484  6D00 0004                247          BLT H2BSKIPPY
00001488  5E07                     248          ADDQ.B  #$7,D7   ; only for A-F
0000148A  0607 0030                249  H2BSKIPPY   ADD.B   #$30,D7
0000148E  4E75                     250          RTS
00001490                           251  
00001490                           252      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B2HSKIPPY           144C
BYTE2HEX            1442
CMP_B               12B4
COM_ADDR            1084
COM_TABL            1067
ENDLOOP             12DC
EXEC                12D0
EXIT                13FC
H2BSKIPPY           148A
H2MDONE             1466
H2MNEXT             1458
H2MRIGHT            145C
HELP                12E4
HELP_MSG            108E
HEX2BYTE            147A
HEX2MEM             1452
INVALID             1402
INVALID_MSG         103A
M2HNEXT             1426
MAX_IN_LEN          50
MDSP                12F8
MDSPADDR2           1320
MDSPDONE            1374
MDSPINV             1370
MDSPLOOP            1330
MEM2HEX             1416
MEM2HEXDONE         143A
MM                  13FA
PROMPT              1288
PROMPT_STR          102C
SEARCH              12AA
SORTW               137A
SORTWA              13CE
SORTWCMP            13C8
SORTWD              13D8
SORTWDONE           13F4
SORTWINV            13F0
SORTWLOOP           13C6
SORTWNEXT           13DE
SORTWSWAP           13E8
STACK               3000
START               1276
WELCOME             1000

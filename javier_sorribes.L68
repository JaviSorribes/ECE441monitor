000014CE Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/20/2017 00:23:43

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 54 48 41 4E 4B 20 ...     11  GOODBYE     DC.B    'THANK YOU FOR USING MONITOR441, SEE YOU SOON!',0
0000105A= 0A 0D 4D 4F 4E 49 ...     12  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
00001068= 49 4E 56 41 4C 49 ...     13  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
00001079= 54 79 70 65 20 48 ...     14              DC.B    'Type HELP for command usage',0
00001095                            15  
00001095= 34 48 45 4C 50 00         16  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000109B= 34 4D 44 53 50 20         17              DC.B    '4MDSP',$20  ; number specifies length of word 
000010A1= 35 53 4F 52 54 57 20      18              DC.B    '5SORTW',$20    ; used for SEARCH (not input)
000010A8= 32 4D 4D 00               19              DC.B    '2MM',0
000010AC= 32 44 46 00               20              DC.B    '2DF',0
000010B0= 34 45 58 49 54 00         21              DC.B    '4EXIT',0
000010B6= 34 43 4F 4E 56 20         22              DC.B    '4CONV',$20
000010BC                            23              
000010BC= 157C                      24  COM_ADDR    DC.W    HELP        ; Command addresses table
000010BE= 1590                      25              DC.W    MDSP
000010C0= 1612                      26              DC.W    SORTW
000010C2= 169A                      27              DC.W    MM
000010C4= 169C                      28              DC.W    DF
000010C6= 16D0                      29              DC.W    EXIT
000010C8= 16EE                      30              DC.W    CONV
000010CA                            31              
000010CA= 48 45 4C 50 3A 20 ...     32  HELP_MSG    DC.B    'HELP: Displays This Message',$A,$A,$D
000010E8= 4D 44 53 50 3A 20 ...     33              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
00001113= 44 65 66 61 75 6C ...     34              DC.B    'Default address2: address1 + 16',$A,$D
00001134= 4D 44 53 50 20 3C ...     35              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
0000116A= 53 4F 52 54 57 3A ...     36              DC.B    'SORTW: Sorts Unsigned Words In A Memory Block',$A,$D
00001199= 42 6F 74 68 20 61 ...     37              DC.B    'Both address1 and address2 are inclusive',$A,$D
000011C3= 44 65 66 61 75 6C ...     38              DC.B    'Default order: descending',$A,$D
000011DE= 53 4F 52 54 57 20 ...     39              DC.B    'SORTW <address1> <address2>[ A|D] eg: SORTW $2000 $201E A<CR>',$A,$A,$D
0000121E= 4D 4D 3A 20 4D 6F ...     40              DC.B    'MM: Modifies Data In Memory',$A,$D
0000123B= 44 65 66 61 75 6C ...     41              DC.B    'Default: Displays one byte',$A,$D
00001257= 57 3A 20 44 69 73 ...     42              DC.B    'W: Displays one word',$A,$D
0000126D= 4C 3A 20 44 69 73 ...     43              DC.B    'L: Displays one long word',$A,$D
00001288= 4D 4D 20 3C 61 64 ...     44              DC.B    'MM <address>[ size]',$A,$A,$D
0000129E                            45              ** Add all others as I go
0000129E= 44 46 3A 20 44 69 ...     46              DC.B    'DF: Displays All Formatted Registers eg: DF<CR>',$A,$A,$D
000012D0= 45 58 49 54 3A 20 ...     47              DC.B    'EXIT: Exit The Monitor Program eg: EXIT<CR>',$A,$A,$D
000012FE= 43 4F 4E 56 3A 20 ...     48              DC.B    'CONV: Convert Hex to Decimal, Or Vice Versa',$A,$D
0000132B= 43 4F 4E 56 20 5B ...     49              DC.B    'CONV [$]num eg: CONV 16<CR> returns $10',0
00001353                            50              
00001353= 44 30 3D 58 58 58 ...     51  DF_MSG      DC.B    'D0=XXXXXXXX D1=XXXXXXXX D2=XXXXXXXX D3=XXXXXXXX',$A,$D
00001384= 44 34 3D 58 58 58 ...     52              DC.B    'D4=XXXXXXXX D5=XXXXXXXX D6=XXXXXXXX D7=XXXXXXXX',$A,$D
000013B5= 41 30 3D 58 58 58 ...     53              DC.B    'A0=XXXXXXXX A1=XXXXXXXX A2=XXXXXXXX A3=XXXXXXXX',$A,$D
000013E6= 41 34 3D 58 58 58 ...     54              DC.B    'A4=XXXXXXXX A5=XXXXXXXX A6=XXXXXXXX A7=XXXXXXXX',0
00001416                            55  DF_MSG_END
00001416                            56           
00001416= 0D 41 64 64 72 65 ...     57  ADDRERR_MSG DC.B    $D,'Address Error Exception',0   
0000142F= 0D 42 75 73 20 45 ...     58  BERR_MSG    DC.B    $D,'Bus Error Exception',0
00001444= 0D 49 6C 6C 65 67 ...     59  ILLINS_MSG  DC.B    $D,'Illegal Instructor Exception',0
00001462= 0D 50 72 69 76 69 ...     60  PRIVERR_MSG DC.B    $D,'Privilege Error Exception',0
0000147D= 0D 44 69 76 69 73 ...     61  DIV0_MSG    DC.B    $D,'Division By Zero Exception',0
00001499= 0D 43 68 65 63 6B ...     62  CHKERR_MSG     DC.B    $D,'Check Exception',0
000014AA= 0D 4C 69 6E 65 20 ...     63  LINEA_MSG   DC.B    $D,'Line A Exception',0
000014BC= 0D 4C 69 6E 65 20 ...     64  LINEF_MSG   DC.B    $D,'Line F Exception',0
000014CE                            65              
000014CE                            66  *** RUNNING PROGRAM ***
000014CE                            67      ;ORG     $1200 --> allow for as much as necessary before this, and add program right after it
000014CE                            68  START:                  ; first instruction of program
000014CE                            69  
000014CE  =00000050                 70  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
000014CE  =00002FFC                 71  STACK       EQU $2FFC   ; $3000 minus a long word because A7 will be stored first
000014CE  21CF 2FFC                 72          MOVE.L  A7,STACK    ; store original location of stack beforehand
000014D2  4FF8 2FFC                 73          LEA     STACK,A7
000014D6  48E7 FFFE                 74          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to restore them
000014DA                            75  
000014DA                            76  ** Populate exception vector table ***
000014DA  21FC 00001844 0008        77          MOVE.L  #BERR,$8
000014E2  21FC 00001832 000C        78          MOVE.L  #ADDRERR,$C
000014EA  21FC 00001856 0010        79          MOVE.L  #ILLINS,$10
000014F2  21FC 0000186E 0014        80          MOVE.L  #DIV0,$14
000014FA  21FC 0000187A 0018        81          MOVE.L  #CHKERR,$18
00001502  21FC 00001862 0020        82          MOVE.L  #PRIVERR,$20
0000150A  21FC 00001886 0028        83          MOVE.L  #LINEA,$28
00001512  21FC 00001892 002C        84          MOVE.L  #LINEF,$2C
0000151A                            85          
0000151A                            86  *** MAIN: Prompt, execute and repeat ***
0000151A  43F8 1000                 87          LEA     WELCOME,A1
0000151E  103C 000D                 88          MOVE.B  #13,D0
00001522  41BC 0000                 89          CHK     #0,D0
00001526  4E4F                      90          TRAP    #15     ; display welcome message
00001528  9FFC 00000050             91          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input (do only once)
0000152E  43F8 105A                 92  PROMPT  LEA     PROMPT_STR,A1  
00001532  103C 000E                 93          MOVE.B  #14,D0
00001536  4E4F                      94          TRAP    #15     ; print out prompt
00001538  224F                      95          MOVEA.L A7,A1   ; input will go in stack
0000153A  103C 0002                 96          MOVE.B  #2,D0
0000153E  4E4F                      97          TRAP    #15     ; read user input, length stored in D1
00001540                            98          
00001540  49F8 1095                 99          LEA     COM_TABL,A4 ; beginning of command table
00001544  4BF8 10BC                100          LEA     COM_ADDR,A5 ; end of command table
00001548  4283                     101          CLR.L   D3      ; will be the count of where the command is
0000154A  4282                     102  SEARCH  CLR.L   D2
0000154C  141C                     103          MOVE.B  (A4)+,D2   ; length of next command string
0000154E  0402 0030                104          SUBI.B  #$30,D2 ; convert ascii num to hex
00001552  2C49                     105          MOVEA.L A1,A6   ; pointer to input string
00001554  BD0C                     106  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
00001556  56CA FFFC                107          DBNE    D2,CMP_B    ; keep comparing characters until length is over
0000155A  4A42                     108          TST.W   D2
0000155C  6D00 0010                109          BLT     EXEC    ; loop was exhausted and all chars were equal
00001560  D9C2                     110          ADDA.L  D2,A4   ; go to end of command
00001562  5483                     111          ADDQ.L  #2,D3   ; else, increment offset by word size
00001564  BBCC                     112          CMPA.L  A4,A5 ; end of COM_TABL
00001566  6CE2                     113          BGE     SEARCH  ; keep on searching
00001568                           114          
00001568  6100 01BC                115          BSR     INVALID ; print invalid command message
0000156C  60C0                     116          BRA     PROMPT ; prompt again
0000156E                           117          
0000156E  DBC3                     118  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
00001570  267C 00000000            119          MOVEA.L #0,A3   ; clear A3, used for subroutine call
00001576  3655                     120          MOVEA.W (A5),A3 ; move that command's address to register
00001578  4E93                     121          JSR     (A3)    ; jump to that command's subroutine (below)
0000157A                           122  
0000157A  60B2                     123          BRA     PROMPT  ; prompt again
0000157C                           124  
0000157C                           125  *** DEBUGGING COMMANDS ***
0000157C                           126  * HELP -- displays help message
0000157C  48E7 8040                127  HELP    MOVEM.L D0/A1,-(A7) ; store used registers in stack
00001580  43F8 10CA                128          LEA     HELP_MSG,A1  
00001584  103C 000D                129          MOVE.B  #13,D0
00001588  4E4F                     130          TRAP    #15     ; print help message
0000158A  4CDF 0201                131          MOVEM.L (A7)+,D0/A1 ; restore registers from stack
0000158E  4E75                     132          RTS
00001590                           133          
00001590                           134  * For this subroutine and others, A6 contains the start of the command's parameters
00001590                           135  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
00001590                           136  
00001590                           137  * MDSP -- displays memory block
00001590  48E7 F878                138  MDSP    MOVEM.L D0-D4/A1-A4,-(A7)
00001594  121E                     139          MOVE.B  (A6)+,D1    ; first '$'
00001596  0C01 0024                140          CMPI.B  #$24,D1 ; is it '$'?
0000159A  6600 006C                141          BNE     MDSPINV ; wrong command usage
0000159E  6100 019A                142          BSR     MEM2HEX ; D1 has 1st address in hex
000015A2  2441                     143          MOVEA.L D1,A2   ;store in A2
000015A4  121E                     144          MOVE.B  (A6)+,D1    ; space in between addresses
000015A6  4A01                     145          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
000015A8  6600 000E                146          BNE     MDSPADDR2
000015AC  264A                     147          MOVEA.L A2,A3
000015AE  D7FC 00000010            148          ADDA.L  #16,A3  ; A3 = A2 +16
000015B4  6000 0012                149          BRA     MDSPLOOP
000015B8  121E                     150  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
000015BA  0C01 0024                151          CMPI.B  #$24,D1
000015BE  6600 0048                152          BNE     MDSPINV
000015C2  6100 0176                153          BSR     MEM2HEX ; D1 has 2nd address in hex
000015C6  2641                     154          MOVEA.L D1,A3
000015C8  224F                     155  MDSPLOOP    MOVEA.L A7,A1
000015CA  93FC 00000040            156          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
000015D0  133C 0000                157          MOVE.B  #$00,-(A1) ; null terminator
000015D4  133C 0020                158          MOVE.B  #$20,-(A1)  ; space
000015D8  133C 003E                159          MOVE.B  #$3E,-(A1)  ; '<' for nicer output
000015DC  220A                     160          MOVE.L  A2,D1
000015DE  6100 0196                161          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
000015E2  133C 0024                162          MOVE.B  #$24,-(A1)  ; '$' for nicer output
000015E6  103C 000E                163          MOVE.B  #14,D0
000015EA  4E4F                     164          TRAP    #15     ; print current memory address
000015EC  133C 0000                165          MOVE.B  #$00,-(A1) ; null terminator
000015F0  133C 0020                166          MOVE.B  #$20,-(A1)  ; space
000015F4  221A                     167          MOVE.L  (A2)+,D1
000015F6  6100 017E                168          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
000015FA  103C 000D                169          MOVE.B  #13,D0
000015FE  4E4F                     170          TRAP    #15     ; print
00001600  B7CA                     171          CMPA.L  A2,A3
00001602  6EC4                     172          BGT     MDSPLOOP
00001604  6000 0006                173          BRA     MDSPDONE
00001608  6100 011C                174  MDSPINV BSR     INVALID ; print invalid command message
0000160C  4CDF 1E1F                175  MDSPDONE    MOVEM.L (A7)+,D0-D4/A1-A4
00001610  4E75                     176          RTS
00001612                           177  
00001612                           178  * SORTW -- implements bubble sort (unsigned numbers)
00001612  48E7 F878                179  SORTW   MOVEM.L D0-D4/A1-A4,-(A7)
00001616  121E                     180          MOVE.B  (A6)+,D1    ; first '$'
00001618  0C01 0024                181          CMPI.B  #$24,D1     ; is it '$'?
0000161C  6600 0072                182          BNE     SORTWINV    ; wrong command usage
00001620  6100 0118                183          BSR     MEM2HEX     ; D1 has 1st address in hex
00001624  2441                     184          MOVEA.L D1,A2       ; store in A2
00001626  121E                     185          MOVE.B  (A6)+,D1    ; space in between addresses
00001628  0C01 0020                186          CMPI.B  #$20,D1     ; is it ' '?
0000162C  6600 0062                187          BNE     SORTWINV    ; wrong command usage
00001630  121E                     188          MOVE.B  (A6)+,D1    ; second '$'
00001632  0C01 0024                189          CMPI.B  #$24,D1     ; is it '$'?
00001636  6600 0058                190          BNE     SORTWINV    ; wrong command usage
0000163A  6100 00FE                191          BSR     MEM2HEX     ; D1 has now the 2nd address
0000163E  2641                     192          MOVEA.L D1,A3       ; store in A3
00001640  121E                     193          MOVE.B  (A6)+,D1    ; space 
00001642  0C01 0000                194          CMPI.B  #$00,D1     ; is it NULL?
00001646  6700 001C                195          BEQ     SORTWDEF    ; use default: descending (D1=0)
0000164A  0C01 0020                196          CMPI.B  #$20,D1     ; or is it ' '?
0000164E  6600 0040                197          BNE     SORTWINV    ; wrong command usage
00001652  121E                     198          MOVE.B  (A6)+,D1    ; char either 'A' or 'D'
00001654  0C01 0041                199          CMPI.B  #$41,D1     ; is it 'A'?
00001658  6700 000C                200          BEQ     SORTWLOOP   ; if so, D1 marks ascending
0000165C  0C01 0044                201          CMPI.B  #$44,D1     ; else, is it 'D'?
00001660  6600 002E                202          BNE     SORTWINV    ; if it isn't, input was invalid
00001664  4281                     203  SORTWDEF    CLR.L   D1          ; if it is, D1=0 marks descending
00001666  284A                     204  SORTWLOOP   MOVEA.L A2,A4   ; first address copied into A4
00001668  4A01                     205  SORTWCMP    TST.B   D1      ; tells us whether ascending or descending
0000166A  6700 000C                206          BEQ     SORTWD  ; do descending
0000166E  B94C                     207  SORTWA  CMP.W   (A4)+,(A4)+ ; compare next two numbers
00001670  6500 0016                208          BCS     SORTWSWAP   ; swap if not in ascending order (if 1st>2nd)
00001674  6000 0008                209          BRA     SORTWNEXT   ; otherwise, move on
00001678  B94C                     210  SORTWD  CMP.W   (A4)+,(A4)+ ; compare next two numbers
0000167A  6200 000C                211          BHI     SORTWSWAP   ; swap if not in descending order (if 2nd>1st)
0000167E  558C                     212  SORTWNEXT   SUBQ.L  #2,A4   ; look back at previous number
00001680  B7CC                     213          CMP.L   A4,A3       
00001682  66E4                     214          BNE     SORTWCMP    ; keep comparing if not at end yet (A3 inclusive)
00001684  6000 000E                215          BRA     SORTWDONE   ; else, done
00001688  2824                     216  SORTWSWAP MOVE.L  -(A4),D4   ; move both words to register
0000168A  4844                     217          SWAP.W  D4  ; swap the two words 
0000168C  2884                     218          MOVE.L  D4,(A4) ; write them back
0000168E  60D6                     219          BRA     SORTWLOOP   ; loop again from start
00001690  6100 0094                220  SORTWINV    BSR INVALID
00001694  4CDF 1E1F                221  SORTWDONE   MOVEM.L (A7)+,D0-D4/A1-A4
00001698  4E75                     222          RTS
0000169A                           223  
0000169A                           224  * MM -- 
0000169A                           225  MM    
0000169A  4E75                     226          RTS
0000169C                           227          
0000169C                           228  * DF -- displays formatted registers
0000169C  48E7 E0C0                229  DF      MOVEM.L D0-D2/A0-A1,-(A7)
000016A0  41F8 2FFC                230          LEA     STACK,A0
000016A4  5888                     231          ADDA.L  #4,A0   ; placed after A7 in stack
000016A6  43F8 1416                232          LEA     DF_MSG_END,A1
000016AA  5389                     233  DFLOOP  SUBQ.L  #1,A1   ; pass the $A at end of each line
000016AC  7403                     234          MOVE.L  #3,D2   ; number of registers per line - 1
000016AE  2220                     235  DFLINE  MOVE.L  -(A0),D1    ; put register value in D1
000016B0  6100 00C4                236          BSR     HEX2MEM     ; will store D1 in -8(A1)
000016B4  5989                     237          SUBQ.L  #4,A1   ; skip other characters
000016B6  51CA FFF6                238          DBF     D2,DFLINE   ; keep looping till line done       
000016BA  B3FC 00001353            239          CMP.L   #DF_MSG,A1
000016C0  6EE8                     240          BGT     DFLOOP
000016C2  5289                     241          ADDQ.L  #1,A1   ; put back at the front of the message
000016C4  103C 000D                242          MOVE.B  #13,D0
000016C8  4E4F                     243          TRAP    #15     ; print register value
000016CA  4CDF 0307                244          MOVEM.L (A7)+,D0-D2/A0-A1
000016CE  4E75                     245          RTS
000016D0                           246  
000016D0                           247  * EXIT -- terminates the program
000016D0  43F8 102C                248  EXIT    LEA     GOODBYE,A1
000016D4  103C 000D                249          MOVE.B  #13,D0
000016D8  4E4F                     250          TRAP    #15     ; print goodbye message
000016DA  588F                     251          ADDA.L  #4,A7   ; move past the PC stored in the stack
000016DC  DFFC 00000050            252          ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input
000016E2  4CDF 7FFF                253          MOVEM.L (A7)+,D0-D7/A0-A6   ; restore all registers in stack
000016E6  2E78 2FFC                254          MOVEA.L STACK,A7
000016EA  6000 01D4                255          BRA     END     ; exit program
000016EE                           256          
000016EE                           257  * The 2 extra commands:
000016EE                           258  * CONV -- takes in hex and returns decimal, or viceversa
000016EE  48E7 C040                259  CONV    MOVEM.L D0-D1/A1,-(A7)
000016F2  121E                     260          MOVE.B  (A6)+,D1
000016F4  0C01 0024                261          CMPI.B  #$24,D1 ; is it '$'?
000016F8  6700 0016                262          BEQ     CONVH2D ; if so, hex to dec
000016FC  538E                     263  CONVD2H SUBQ.L  #1,A6   ; point back at first number
000016FE  6100 00E2                264          BSR     MEM2DEC ; D1 contains the decimal number
00001702  224E                     265          MOVEA.L A6,A1   ; number ready to print
00001704  6100 0098                266          BSR     HEX2MEM_NOZ ; that number is written as hex in memory
00001708  133C 0024                267          MOVE.B  #'$',-(A1)
0000170C  6000 000C                268          BRA     CONVDONE
00001710  6100 0028                269  CONVH2D BSR     MEM2HEX ; convert ascii to hex
00001714  224E                     270          MOVEA.L A6,A1   ;number ready to print
00001716  6100 00F8                271          BSR     DEC2MEM ; convert it back to ascii but as decimal
0000171A  103C 000D                272  CONVDONE MOVE.B #13,D0
0000171E  4E4F                     273          TRAP    #15 ; print result
00001720  4CDF 0203                274          MOVEM.L (A7)+,D0-D1/A1
00001724  4E75                     275          RTS
00001726                           276  
00001726                           277  *** HELPERS ***
00001726                           278  * Print INVALID message:
00001726  48E7 8040                279  INVALID MOVEM.L D0/A1,-(A7)
0000172A  43F8 1068                280          LEA     INVALID_MSG,A1  ; command was invalid
0000172E  103C 000D                281          MOVE.B  #13,D0
00001732  4E4F                     282          TRAP    #15     ; output invalid command
00001734  4CDF 0201                283          MOVEM.L (A7)+,D0/A1
00001738  4E75                     284          RTS
0000173A                           285  
0000173A                           286  * Takes X digits from (A6) in ascii and puts them in D1 as hex:
0000173A  48E7 8100                287  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
0000173E  4281                     288          CLR.L   D1
00001740  1E1E                     289          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001742  0C07 0030                290          CMPI.B  #$30,D7
00001746  6D00 0016                291          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
0000174A  6100 001A                292  M2HNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
0000174E  D207                     293          ADD.B   D7,D1
00001750  1E1E                     294          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001752  0C07 0030                295          CMPI.B  #$30,D7
00001756  6D00 0006                296          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
0000175A  E981                     297          ASL.L   #4,D1   ; skip this the last time
0000175C  60EC                     298          BRA     M2HNEXT ; loop again because not done
0000175E  538E                     299  M2HDONE SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
00001760  4CDF 0081                300          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001764  4E75                     301          RTS
00001766                           302  
00001766                           303  * Takes byte in ascii in D7 and converts it to digit in D7:
00001766                           304  * Assumes 0-9 or A-F
00001766  0C07 0040                305  ASCII2NUM   CMPI.B #$40,D7
0000176A  6D00 0004                306          BLT A2NSKIPPY
0000176E  5F07                     307          SUBQ.B  #$7,D7   ; only for A-F
00001770  0407 0030                308  A2NSKIPPY   SUB.B   #$30,D7
00001774  4E75                     309          RTS
00001776                           310          
00001776                           311  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001776  48E7 A100                312  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
0000177A  4280                     313          CLR.L   D0   ; counter
0000177C  2E01                     314  H2MNEXT MOVE.L  D1,D7
0000177E  2400                     315          MOVE.L D0,D2
00001780  5342                     316  H2MRIGHT    SUBQ.W  #1,D2
00001782  6D00 0006                317          BLT     H2MDONE
00001786  E88F                     318          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001788  60F6                     319          BRA     H2MRIGHT
0000178A  6100 0040                320  H2MDONE BSR     NUM2ASCII   ; convert to ascii in D7
0000178E  1307                     321          MOVE.B  D7,-(A1)
00001790  5240                     322          ADDQ.W  #1,D0
00001792  0C40 0008                323          CMPI.W  #8,D0
00001796  6DE4                     324          BLT     H2MNEXT
00001798  4CDF 0085                325          MOVEM.L (A7)+,D0/D2/D7
0000179C  4E75                     326          RTS
0000179E                           327          
0000179E                           328  * Takes X digits from D1 in hex and puts them into -X(A1) in ascii (no trailing zeros):
0000179E  48E7 A100                329  HEX2MEM_NOZ MOVEM.L D0/D2/D7,-(A7)    ; store in stack
000017A2  4280                     330          CLR.L   D0   ; counter
000017A4  2E01                     331  H2MZNEXT MOVE.L  D1,D7
000017A6  2400                     332          MOVE.L D0,D2
000017A8  5342                     333  H2MZRIGHT    SUBQ.W  #1,D2
000017AA  6D00 0006                334          BLT     H2MZDONE
000017AE  E88F                     335          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
000017B0  60F6                     336          BRA     H2MZRIGHT
000017B2  4A87                     337  H2MZDONE TST.L   D7
000017B4  6700 0010                338          BEQ     H2MZEND      ; if number done
000017B8  6100 0012                339          BSR     NUM2ASCII   ; convert to ascii in D7
000017BC  1307                     340          MOVE.B  D7,-(A1)
000017BE  5240                     341          ADDQ.W  #1,D0
000017C0  0C40 0008                342          CMPI.W  #8,D0
000017C4  6DDE                     343          BLT     H2MZNEXT
000017C6  4CDF 0085                344  H2MZEND  MOVEM.L (A7)+,D0/D2/D7
000017CA  4E75                     345          RTS
000017CC                           346  
000017CC                           347  * Takes digit in D7 and converts it to ascii byte in D7:
000017CC                           348  * Assumes 0-9 or A-F
000017CC  CEBC 0000000F            349  NUM2ASCII   AND.L  #$0F,D7 ; mask and take only smallest hex digit
000017D2  0C07 000A                350          CMPI.B  #$A,D7
000017D6  6D00 0004                351          BLT N2ASKIPPY
000017DA  5E07                     352          ADDQ.B  #$7,D7   ; only for A-F
000017DC  0607 0030                353  N2ASKIPPY   ADD.B   #$30,D7
000017E0  4E75                     354          RTS
000017E2                           355          
000017E2                           356  * Takes X digits from (A6) in ascii and puts them in D1 as dec:
000017E2  48E7 8100                357  MEM2DEC MOVEM.L D0/D7,-(A7)    ; store in stack
000017E6  4281                     358          CLR.L   D1
000017E8  1E1E                     359          MOVE.B (A6)+,D7    ; read in next byte (prime read)
000017EA  0C07 0030                360          CMPI.B  #$30,D7
000017EE  6D00 0018                361          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
000017F2  6100 FF72                362  M2DNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
000017F6  D207                     363          ADD.B   D7,D1
000017F8  1E1E                     364          MOVE.B (A6)+,D7    ; read in next byte (prime read)
000017FA  0C07 0030                365          CMPI.B  #$30,D7
000017FE  6D00 0008                366          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
00001802  C2FC 000A                367          MULU    #10,D1   ; skip this the last time
00001806  60EA                     368          BRA     M2DNEXT ; loop again because not done
00001808  538E                     369  M2DDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
0000180A  4CDF 0081                370          MOVEM.L (A7)+,D0/D7    ; restore from stack
0000180E  4E75                     371          RTS
00001810                           372  
00001810                           373  * Takes number from D1 in dec and puts them into -X(A1) in ascii:
00001810  48E7 2100                374  DEC2MEM MOVEM.L D2/D7,-(A7)    ; store in stack
00001814  2401                     375          MOVE.L  D1,D2
00001816  84FC 000A                376  D2MLOOP DIVU    #10,D2
0000181A  2E02                     377          MOVE.L  D2,D7
0000181C  4847                     378          SWAP.W  D7
0000181E  61AC                     379          BSR     NUM2ASCII
00001820  1307                     380          MOVE.B  D7,-(A1)
00001822  C4BC 0000FFFF            381          AND.L   #$0000FFFF,D2 ; make sure we use only word in next divisions
00001828  4A42                     382          TST.W   D2
0000182A  66EA                     383          BNE     D2MLOOP
0000182C  4CDF 0084                384          MOVEM.L (A7)+,D2/D7
00001830  4E75                     385          RTS
00001832                           386          
00001832                           387  *** EXCEPTION HANDLERS ***
00001832  48E7 8040                388  ADDRERR MOVEM.L D0/A1,-(A7)
00001836  43F8 1416                389          LEA     ADDRERR_MSG,A1
0000183A  103C 000D                390          MOVE.B  #13,D0
0000183E  4E4F                     391          TRAP    #15
00001840  6000 005C                392          BRA     INTERR_REG  ; print the special registers
00001844  48E7 8040                393  BERR    MOVEM.L D0/A1,-(A7)
00001848  43F8 142F                394          LEA     BERR_MSG,A1
0000184C  103C 000D                395          MOVE.B  #13,D0
00001850  4E4F                     396          TRAP    #15
00001852  6000 004A                397          BRA     INTERR_REG  ; print the special registers
00001856  48E7 8040                398  ILLINS  MOVEM.L D0/A1,-(A7)
0000185A  43F8 1444                399          LEA     ILLINS_MSG,A1
0000185E  6000 003E                400          BRA     INTERR 
00001862  48E7 8040                401  PRIVERR MOVEM.L D0/A1,-(A7)
00001866  43F8 1462                402          LEA     PRIVERR_MSG,A1
0000186A  6000 0032                403          BRA     INTERR 
0000186E  48E7 8040                404  DIV0    MOVEM.L D0/A1,-(A7)
00001872  43F8 147D                405          LEA     DIV0_MSG,A1
00001876  6000 0026                406          BRA     INTERR 
0000187A  48E7 8040                407  CHKERR  MOVEM.L D0/A1,-(A7)
0000187E  43F8 1499                408          LEA     CHKERR_MSG,A1
00001882  6000 001A                409          BRA     INTERR 
00001886  48E7 8040                410  LINEA   MOVEM.L D0/A1,-(A7)
0000188A  43F8 14AA                411          LEA     LINEA_MSG,A1
0000188E  6000 000E                412          BRA     INTERR 
00001892  48E7 8040                413  LINEF   MOVEM.L D0/A1,-(A7)
00001896  43F8 14BC                414          LEA     LINEF_MSG,A1
0000189A  6000 0002                415          BRA     INTERR
0000189E                           416  INTERR_REG  ; only BERR and ADDRERR do this
0000189E                           417          ;;;;;;;;;;;;;; still need to print 3 special registers   
0000189E  103C 000D                418  INTERR  MOVE.B  #13,D0
000018A2  4E4F                     419          TRAP    #15 ; print corresponding message for that interrupt
000018A4  6100 FDF6                420          BSR     DF  ; print registers
000018A8  4CDF 0201                421          MOVEM.L (A7)+,D0/A1 ; do here to be able to modify values of A7
000018AC  4FF8 2FFC                422          LEA     STACK,A7    ; next 3 instructions put A7 at beginning of input space in stack
000018B0  9FFC 0000003C            423          SUBA.L  #60,A7  ; 15 registers that occupy 4 bytes each (2*4 = 8 bits)
000018B6  9FFC 00000050            424          SUBA.L  #MAX_IN_LEN,A7  ; the input space
000018BC  6000 FC70                425          BRA     PROMPT
000018C0                           426  
000018C0                           427  END
000018C0                           428      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2NSKIPPY           1770
ADDRERR             1832
ADDRERR_MSG         1416
ASCII2NUM           1766
BERR                1844
BERR_MSG            142F
CHKERR              187A
CHKERR_MSG          1499
CMP_B               1554
COM_ADDR            10BC
COM_TABL            1095
CONV                16EE
CONVD2H             16FC
CONVDONE            171A
CONVH2D             1710
D2MLOOP             1816
DEC2MEM             1810
DF                  169C
DFLINE              16AE
DFLOOP              16AA
DF_MSG              1353
DF_MSG_END          1416
DIV0                186E
DIV0_MSG            147D
END                 18C0
EXEC                156E
EXIT                16D0
GOODBYE             102C
H2MDONE             178A
H2MNEXT             177C
H2MRIGHT            1780
H2MZDONE            17B2
H2MZEND             17C6
H2MZNEXT            17A4
H2MZRIGHT           17A8
HELP                157C
HELP_MSG            10CA
HEX2MEM             1776
HEX2MEM_NOZ         179E
ILLINS              1856
ILLINS_MSG          1444
INTERR              189E
INTERR_REG          189E
INVALID             1726
INVALID_MSG         1068
LINEA               1886
LINEA_MSG           14AA
LINEF               1892
LINEF_MSG           14BC
M2DDONE             1808
M2DNEXT             17F2
M2HDONE             175E
M2HNEXT             174A
MAX_IN_LEN          50
MDSP                1590
MDSPADDR2           15B8
MDSPDONE            160C
MDSPINV             1608
MDSPLOOP            15C8
MEM2DEC             17E2
MEM2HEX             173A
MM                  169A
N2ASKIPPY           17DC
NUM2ASCII           17CC
PRIVERR             1862
PRIVERR_MSG         1462
PROMPT              152E
PROMPT_STR          105A
SEARCH              154A
SORTW               1612
SORTWA              166E
SORTWCMP            1668
SORTWD              1678
SORTWDEF            1664
SORTWDONE           1694
SORTWINV            1690
SORTWLOOP           1666
SORTWNEXT           167E
SORTWSWAP           1688
STACK               2FFC
START               14CE
WELCOME             1000

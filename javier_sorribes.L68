00001702 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/23/2017 12:59:19

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Monitor Design Project
00000000                             3  * Written by : Javier Sorribes
00000000                             4  * Date       : 4/2/17
00000000                             5  * Description: Some crazy, crazy stuff
00000000                             6  *-----------------------------------------------------------
00000000                             7  *** MEMORY INITIALIZATION ***
00001000                             8      ORG     $1000       ; stack and other memory
00001000                             9  ; $A is newline, $D carriage return, $20 whitespace
00001000= 57 45 4C 43 4F 4D ...     10  WELCOME     DC.B    'WELCOME TO MONITOR441! - BY JAVIER SORRIBES',0
0000102C= 54 48 41 4E 4B 20 ...     11  GOODBYE     DC.B    'THANK YOU FOR USING MONITOR441, SEE YOU SOON!',0
0000105A= 0A 0D 4D 4F 4E 49 ...     12  PROMPT_STR  DC.B    $A,$D,'MONITOR441>',0 ; might want to add one space
00001068= 49 4E 56 41 4C 49 ...     13  INVALID_MSG DC.B    'INVALID COMMAND',$A,$D
00001079= 54 79 70 65 20 48 ...     14              DC.B    'Type HELP for command usage',0
00001095                            15  
00001095= 34 48 45 4C 50 00         16  COM_TABL    DC.B    '4HELP',0   ; Command names table
0000109B= 34 4D 44 53 50 20         17              DC.B    '4MDSP',$20  ; number specifies length of word 
000010A1= 35 53 4F 52 54 57 20      18              DC.B    '5SORTW',$20    ; used for SEARCH (not input)
000010A8= 32 4D 4D 20               19              DC.B    '2MM',$20
000010AC= 32 42 46 20               20              DC.B    '2BF',$20
000010B0= 34 42 4D 4F 56 20         21              DC.B    '4BMOV',$20
000010B6= 34 42 54 53 54 20         22              DC.B    '4BTST',$20
000010BC= 32 47 4F 20               23              DC.B    '2GO',$20
000010C0= 32 44 46 00               24              DC.B    '2DF',0
000010C4= 34 45 58 49 54 00         25              DC.B    '4EXIT',0
000010CA= 34 43 4F 4E 56 20         26              DC.B    '4CONV',$20
000010D0                            27              
000010D0= 17AC                      28  COM_ADDR    DC.W    HELP        ; Command addresses table
000010D2= 17D0                      29              DC.W    MDSP
000010D4= 184E                      30              DC.W    SORTW
000010D6= 18D6                      31              DC.W    MM
000010D8= 1A14                      32              DC.W    BF
000010DA= 1A82                      33              DC.W    BMOV
000010DC= 1B2C                      34              DC.W    BTST
000010DE= 1BEA                      35              DC.W    GO
000010E0= 1C0E                      36              DC.W    DF
000010E2= 1C42                      37              DC.W    EXIT
000010E4= 1C60                      38              DC.W    CONV
000010E6                            39              
000010E6= 48 45 4C 50 3A 20 ...     40  HELP_MSG    DC.B    'HELP: Displays This Message',$A,$A,$D
00001104= 4D 44 53 50 3A 20 ...     41              DC.B    'MDSP: Outputs Address And Memory Contents',$A,$D
0000112F= 44 65 66 61 75 6C ...     42              DC.B    'Default address2: address1 + 16',$A,$D
00001150= 4D 44 53 50 20 3C ...     43              DC.B    'MDSP <address1>[ <address2>] eg: MDSP $908 $904<CR>',$A,$A,$D
00001186= 53 4F 52 54 57 3A ...     44              DC.B    'SORTW: Sorts Unsigned Words In A Memory Block',$A,$D
000011B5= 42 6F 74 68 20 61 ...     45              DC.B    'Both address1 and address2 are inclusive',$A,$D
000011DF= 44 65 66 61 75 6C ...     46              DC.B    'Default order: descending',$A,$D
000011FA= 53 4F 52 54 57 20 ...     47              DC.B    'SORTW <address1> <address2>[ A|D] eg: SORTW $2000 $201E A<CR>',$A,$A,$D
0000123A= 4D 4D 3A 20 4D 6F ...     48              DC.B    'MM: Modifies Data In Memory',$A,$D
00001257= 44 65 66 61 75 6C ...     49              DC.B    'Default: Displays one byte',$A,$D
00001273= 57 3A 20 44 69 73 ...     50              DC.B    'W: Displays one word',$A,$D
00001289= 4C 3A 20 44 69 73 ...     51              DC.B    'L: Displays one long word',$A,$D
000012A4= 4D 4D 20 3C 61 64 ...     52              DC.B    'MM <address>[ size]',$A,$A,$D
000012BA= 42 46 3A 20 46 69 ...     53              DC.B    'BF: Fills Block Of Memory With Word Pattern',$A,$D
000012E7= 42 6F 74 68 20 61 ...     54              DC.B    'Both addresses must be even',$A,$D
00001304= 44 65 66 61 75 6C ...     55              DC.B    'Default pattern: 0000',$A,$D
0000131B= 49 66 20 6C 65 73 ...     56              DC.B    'If less than 4 digits given, right justified and zero padded',$A,$D
00001359= 42 46 20 3C 61 64 ...     57              DC.B    'BF <address1> <address2>[ pattern] eg: BF $2000 $2200 4325<CR>',0
00001398                            58  HELP_MSG2
00001398                            59              ** Add all others as I go
00001398= 42 4D 4F 56 3A 20 ...     60              DC.B    'BMOV: Duplicate A Memory Block At Another Address',$A,$D
000013CB= 4D 75 73 74 20 70 ...     61              DC.B    'Must provide two addresses (inclusive, exclusive) for first block',$A,$D
0000140E= 4F 6E 6C 79 20 6F ...     62              DC.B    'Only one address (inclusive start) for second block',$A,$D
00001443= 42 4D 4F 56 20 3C ...     63              DC.B    'BMOV <address1.1> <address1.2> <address2>',$A,$A,$D
0000146F= 42 54 53 54 3A 20 ...     64              DC.B    'BTST: Test Memory Block',$A,$D
00001488= 42 54 53 54 20 3C ...     65              DC.B    'BTST <address1> <address2>',$A,$A,$D
000014A5= 47 4F 3A 20 45 78 ...     66              DC.B    'GO: Execute Another Program',$A,$D
000014C2= 47 4F 20 3C 61 64 ...     67              DC.B    'GO <address1>',$A,$A,$D
000014D2= 44 46 3A 20 44 69 ...     68              DC.B    'DF: Displays All Formatted Registers eg: DF<CR>',$A,$A,$D
00001504= 45 58 49 54 3A 20 ...     69              DC.B    'EXIT: Exit The Monitor Program eg: EXIT<CR>',$A,$A,$D
00001532= 43 4F 4E 56 3A 20 ...     70              DC.B    'CONV: Convert Hex to Decimal, Or Vice Versa',$A,$D
0000155F= 43 4F 4E 56 20 5B ...     71              DC.B    'CONV [$]num eg: CONV 16<CR> returns $10',0
00001587                            72              
00001587= 44 30 3D 58 58 58 ...     73  DF_MSG      DC.B    'D0=XXXXXXXX D1=XXXXXXXX D2=XXXXXXXX D3=XXXXXXXX',$A,$D
000015B8= 44 34 3D 58 58 58 ...     74              DC.B    'D4=XXXXXXXX D5=XXXXXXXX D6=XXXXXXXX D7=XXXXXXXX',$A,$D
000015E9= 41 30 3D 58 58 58 ...     75              DC.B    'A0=XXXXXXXX A1=XXXXXXXX A2=XXXXXXXX A3=XXXXXXXX',$A,$D
0000161A= 41 34 3D 58 58 58 ...     76              DC.B    'A4=XXXXXXXX A5=XXXXXXXX A6=XXXXXXXX A7=XXXXXXXX',0
0000164A                            77  DF_MSG_END
0000164A                            78           
0000164A= 0D 41 64 64 72 65 ...     79  ADDRERR_MSG DC.B    $D,'Address Error Exception',0   
00001663= 0D 42 75 73 20 45 ...     80  BERR_MSG    DC.B    $D,'Bus Error Exception',0
00001678= 0D 49 6C 6C 65 67 ...     81  ILLINS_MSG  DC.B    $D,'Illegal Instructor Exception',0
00001696= 0D 50 72 69 76 69 ...     82  PRIVERR_MSG DC.B    $D,'Privilege Error Exception',0
000016B1= 0D 44 69 76 69 73 ...     83  DIV0_MSG    DC.B    $D,'Division By Zero Exception',0
000016CD= 0D 43 68 65 63 6B ...     84  CHKERR_MSG  DC.B    $D,'Check Exception',0
000016DE= 0D 4C 69 6E 65 20 ...     85  LINEA_MSG   DC.B    $D,'Line A Exception',0
000016F0= 0D 4C 69 6E 65 20 ...     86  LINEF_MSG   DC.B    $D,'Line F Exception',0
00001702                            87              
00001702                            88  *** RUNNING PROGRAM ***
00001702                            89      ;ORG     $1200 --> allow for as much as necessary before this, and add program right after it
00001702                            90  START:                  ; first instruction of program
00001702                            91  
00001702  =00000050                 92  MAX_IN_LEN  EQU 80  ; to ensure input won't overflow stack
00001702  =00002FFC                 93  STACK       EQU $2FFC   ; $3000 minus a long word because A7 will be stored first
00001702  21CF 2FFC                 94          MOVE.L  A7,STACK    ; store original location of stack beforehand
00001706  4FF8 2FFC                 95          LEA     STACK,A7
0000170A  48E7 FFFE                 96          MOVEM.L D0-D7/A0-A6,-(A7)   ; store all registers in stack. Want to be able to restore them
0000170E                            97  
0000170E                            98  ** Populate exception vector table ***
0000170E  21FC 00001DBA 0008        99          MOVE.L  #BERR,$8
00001716  21FC 00001DA4 000C       100          MOVE.L  #ADDRERR,$C
0000171E  21FC 00001DD0 0010       101          MOVE.L  #ILLINS,$10
00001726  21FC 00001DE8 0014       102          MOVE.L  #DIV0,$14
0000172E  21FC 00001DF4 0018       103          MOVE.L  #CHKERR,$18
00001736  21FC 00001DDC 0020       104          MOVE.L  #PRIVERR,$20
0000173E  21FC 00001E00 0028       105          MOVE.L  #LINEA,$28
00001746  21FC 00001E0C 002C       106          MOVE.L  #LINEF,$2C
0000174E                           107          
0000174E                           108  *** MAIN: Prompt, execute and repeat ***
0000174E  43F8 1000                109          LEA     WELCOME,A1
00001752  103C 000D                110          MOVE.B  #13,D0
00001756  4E4F                     111          TRAP    #15     ; display welcome message
00001758  9FFC 00000050            112          SUBA.L  #MAX_IN_LEN,A7  ; open space in stack for input (do only once)
0000175E  43F8 105A                113  PROMPT  LEA     PROMPT_STR,A1  
00001762  103C 000E                114          MOVE.B  #14,D0
00001766  4E4F                     115          TRAP    #15     ; print out prompt
00001768  224F                     116          MOVEA.L A7,A1   ; input will go in stack
0000176A  103C 0002                117          MOVE.B  #2,D0
0000176E  4E4F                     118          TRAP    #15     ; read user input, length stored in D1
00001770                           119          
00001770  49F8 1095                120          LEA     COM_TABL,A4 ; beginning of command table
00001774  4BF8 10D0                121          LEA     COM_ADDR,A5 ; end of command table
00001778  4283                     122          CLR.L   D3      ; will be the count of where the command is
0000177A  4282                     123  SEARCH  CLR.L   D2
0000177C  141C                     124          MOVE.B  (A4)+,D2   ; length of next command string
0000177E  0402 0030                125          SUBI.B  #$30,D2 ; convert ascii num to hex
00001782  2C49                     126          MOVEA.L A1,A6   ; pointer to input string
00001784  BD0C                     127  CMP_B   CMPM.B  (A4)+,(A6)+ ; compare byte to byte with command names
00001786  56CA FFFC                128          DBNE    D2,CMP_B    ; keep comparing characters until length is over
0000178A  4A42                     129          TST.W   D2
0000178C  6D00 0010                130          BLT     EXEC    ; loop was exhausted and all chars were equal
00001790  D9C2                     131          ADDA.L  D2,A4   ; go to end of command
00001792  5483                     132          ADDQ.L  #2,D3   ; else, increment offset by word size
00001794  BBCC                     133          CMPA.L  A4,A5 ; end of COM_TABL
00001796  6CE2                     134          BGE     SEARCH  ; keep on searching
00001798                           135          
00001798  6100 04FE                136          BSR     INVALID ; print invalid command message
0000179C  60C0                     137          BRA     PROMPT ; prompt again
0000179E                           138          
0000179E  DBC3                     139  EXEC    ADDA.L  D3,A5   ; add offset to COM_ADDR start
000017A0  267C 00000000            140          MOVEA.L #0,A3   ; clear A3, used for subroutine call
000017A6  3655                     141          MOVEA.W (A5),A3 ; move that command's address to register
000017A8  4E93                     142          JSR     (A3)    ; jump to that command's subroutine (below)
000017AA                           143  
000017AA  60B2                     144          BRA     PROMPT  ; prompt again
000017AC                           145  
000017AC                           146  *** DEBUGGING COMMANDS ***
000017AC                           147  * HELP -- displays help message
000017AC  48E7 C040                148  HELP    MOVEM.L D0-D1/A1,-(A7) ; store used registers in stack
000017B0  43F8 10E6                149          LEA     HELP_MSG,A1  
000017B4  103C 000D                150          MOVE.B  #13,D0
000017B8  4E4F                     151          TRAP    #15     ; print first part of the help message
000017BA  103C 0005                152          MOVE.B  #5,D0
000017BE  4E4F                     153          TRAP    #15     ; wait for the user to enter a character
000017C0  43F8 1398                154          LEA     HELP_MSG2,A1
000017C4  103C 000D                155          MOVE.B  #13,D0
000017C8  4E4F                     156          TRAP    #15     ; print second half of the message
000017CA  4CDF 0203                157          MOVEM.L (A7)+,D0-D1/A1 ; restore registers from stack
000017CE  4E75                     158          RTS
000017D0                           159          
000017D0                           160  * For this subroutine and others, A6 contains the start of the command's parameters
000017D0                           161  * eg: MDSP $1230 $1890 <- A6 points to the first '$'
000017D0                           162  
000017D0                           163  * MDSP -- displays memory block
000017D0  48E7 F878                164  MDSP    MOVEM.L D0-D4/A1-A4,-(A7)
000017D4  121E                     165          MOVE.B  (A6)+,D1    ; first '$'
000017D6  0C01 0024                166          CMPI.B  #$24,D1 ; is it '$'?
000017DA  6600 0068                167          BNE     MDSPINV ; wrong command usage
000017DE  6100 04CC                168          BSR     MEM2HEX ; D1 has 1st address in hex
000017E2  2441                     169          MOVEA.L D1,A2   ;store in A2
000017E4  121E                     170          MOVE.B  (A6)+,D1    ; space in between addresses
000017E6  4A01                     171          TST.B   D1  ; if null, no 2nd address, so address2 = address1 + 16
000017E8  6600 000E                172          BNE     MDSPADDR2
000017EC  264A                     173          MOVEA.L A2,A3
000017EE  D7FC 00000010            174          ADDA.L  #16,A3  ; A3 = A2 +16
000017F4  6000 0012                175          BRA     MDSPLOOP
000017F8  121E                     176  MDSPADDR2   MOVE.B  (A6)+,D1    ; second '$'
000017FA  0C01 0024                177          CMPI.B  #$24,D1
000017FE  6600 0044                178          BNE     MDSPINV
00001802  6100 04A8                179          BSR     MEM2HEX ; D1 has 2nd address in hex
00001806  2641                     180          MOVEA.L D1,A3
00001808  224F                     181  MDSPLOOP    MOVEA.L A7,A1
0000180A  93FC 00000040            182          SUBA.L  #$40,A1 ; move A1 far from A7 to avoid collision in subroutines
00001810  133C 0000                183          MOVE.B  #$00,-(A1) ; null terminator
00001814  133C 0020                184          MOVE.B  #$20,-(A1)  ; space
00001818  133C 003E                185          MOVE.B  #$3E,-(A1)  ; '>' for nicer output
0000181C  220A                     186          MOVE.L  A2,D1   ; memory address into D1
0000181E  6100 04C8                187          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
00001822  133C 0024                188          MOVE.B  #$24,-(A1)  ; '$' for nicer output
00001826  103C 000E                189          MOVE.B  #14,D0
0000182A  4E4F                     190          TRAP    #15     ; print current memory address
0000182C  133C 0000                191          MOVE.B  #$00,-(A1)  ; null terminator
00001830  221A                     192          MOVE.L  (A2)+,D1    ; memory value into D1
00001832  6100 04B4                193          BSR     HEX2MEM ; puts digits of D1 into -X(A1) in ascii (no trailing zeros)
00001836  103C 000D                194          MOVE.B  #13,D0
0000183A  4E4F                     195          TRAP    #15     ; print
0000183C  B7CA                     196          CMPA.L  A2,A3
0000183E  6EC8                     197          BGT     MDSPLOOP
00001840  6000 0006                198          BRA     MDSPDONE
00001844  6100 0452                199  MDSPINV BSR     INVALID ; print invalid command message
00001848  4CDF 1E1F                200  MDSPDONE    MOVEM.L (A7)+,D0-D4/A1-A4
0000184C  4E75                     201          RTS
0000184E                           202  
0000184E                           203  * SORTW -- implements bubble sort (unsigned numbers)
0000184E  48E7 F878                204  SORTW   MOVEM.L D0-D4/A1-A4,-(A7)
00001852  121E                     205          MOVE.B  (A6)+,D1    ; first '$'
00001854  0C01 0024                206          CMPI.B  #$24,D1     ; is it '$'?
00001858  6600 0072                207          BNE     SORTWINV    ; wrong command usage
0000185C  6100 044E                208          BSR     MEM2HEX     ; D1 has 1st address in hex
00001860  2441                     209          MOVEA.L D1,A2       ; store in A2
00001862  121E                     210          MOVE.B  (A6)+,D1    ; space in between addresses
00001864  0C01 0020                211          CMPI.B  #$20,D1     ; is it ' '?
00001868  6600 0062                212          BNE     SORTWINV    ; wrong command usage
0000186C  121E                     213          MOVE.B  (A6)+,D1    ; second '$'
0000186E  0C01 0024                214          CMPI.B  #$24,D1     ; is it '$'?
00001872  6600 0058                215          BNE     SORTWINV    ; wrong command usage
00001876  6100 0434                216          BSR     MEM2HEX     ; D1 has now the 2nd address
0000187A  2641                     217          MOVEA.L D1,A3       ; store in A3
0000187C  121E                     218          MOVE.B  (A6)+,D1    ; space 
0000187E  0C01 0000                219          CMPI.B  #$00,D1     ; is it NULL?
00001882  6700 001C                220          BEQ     SORTWDEF    ; use default: descending (D1=0)
00001886  0C01 0020                221          CMPI.B  #$20,D1     ; or is it ' '?
0000188A  6600 0040                222          BNE     SORTWINV    ; wrong command usage
0000188E  121E                     223          MOVE.B  (A6)+,D1    ; char either 'A' or 'D'
00001890  0C01 0041                224          CMPI.B  #$41,D1     ; is it 'A'?
00001894  6700 000C                225          BEQ     SORTWLOOP   ; if so, D1 marks ascending
00001898  0C01 0044                226          CMPI.B  #$44,D1     ; else, is it 'D'?
0000189C  6600 002E                227          BNE     SORTWINV    ; if it isn't, input was invalid
000018A0  4281                     228  SORTWDEF    CLR.L   D1          ; if it is, D1=0 marks descending
000018A2  284A                     229  SORTWLOOP   MOVEA.L A2,A4   ; first address copied into A4
000018A4  4A01                     230  SORTWCMP    TST.B   D1      ; tells us whether ascending or descending
000018A6  6700 000C                231          BEQ     SORTWD  ; do descending
000018AA  B94C                     232  SORTWA  CMP.W   (A4)+,(A4)+ ; compare next two numbers
000018AC  6500 0016                233          BCS     SORTWSWAP   ; swap if not in ascending order (if 1st>2nd)
000018B0  6000 0008                234          BRA     SORTWNEXT   ; otherwise, move on
000018B4  B94C                     235  SORTWD  CMP.W   (A4)+,(A4)+ ; compare next two numbers
000018B6  6200 000C                236          BHI     SORTWSWAP   ; swap if not in descending order (if 2nd>1st)
000018BA  558C                     237  SORTWNEXT   SUBQ.L  #2,A4   ; look back at previous number
000018BC  B7CC                     238          CMP.L   A4,A3       
000018BE  66E4                     239          BNE     SORTWCMP    ; keep comparing if not at end yet (A3 inclusive)
000018C0  6000 000E                240          BRA     SORTWDONE   ; else, done
000018C4  2824                     241  SORTWSWAP MOVE.L  -(A4),D4   ; move both words to register
000018C6  4844                     242          SWAP.W  D4  ; swap the two words 
000018C8  2884                     243          MOVE.L  D4,(A4) ; write them back
000018CA  60D6                     244          BRA     SORTWLOOP   ; loop again from start
000018CC  6100 03CA                245  SORTWINV    BSR INVALID
000018D0  4CDF 1E1F                246  SORTWDONE   MOVEM.L (A7)+,D0-D4/A1-A4
000018D4  4E75                     247          RTS
000018D6                           248  
000018D6                           249  * MM -- modifies data in memory. Size can be B, W or L
000018D6  48E7 C0C0                250  MM      MOVEM.L D0-D1/A0-A1,-(A7)
000018DA  224E                     251          MOVEA.L A6,A1   ; A1 used for I/O later
000018DC  121E                     252          MOVE.B  (A6)+,D1    ; '$'
000018DE  0C01 0024                253          CMPI.B  #$24,D1 ; is it '$'?
000018E2  6600 03B4                254          BNE     INVALID ; wrong command usage
000018E6  6100 03C4                255          BSR     MEM2HEX ; D1 has address in hex
000018EA  2041                     256          MOVEA.L D1,A0   ;store in A0
000018EC  121E                     257          MOVE.B  (A6)+,D1    ; ' ' before option
000018EE  0C01 0000                258          CMPI.B  #0,D1       ; is it null?
000018F2  6700 0028                259          BEQ     MMBYTE  ; use default: byte
000018F6  0C01 0020                260          CMPI.B  #$20,D1 ; is it ' '?
000018FA  6600 039C                261          BNE     INVALID ; wrong command usage
000018FE  121E                     262          MOVE.B  (A6)+,D1    ; the option
00001900  0C01 0042                263          CMPI.B  #'B',D1
00001904  6700 0016                264          BEQ     MMBYTE
00001908  0C01 0057                265          CMPI.B  #'W',D1
0000190C  6700 005E                266          BEQ     MMWORD
00001910  0C01 004C                267          CMPI.B  #'L',D1
00001914  6700 00A6                268          BEQ     MMLONG
00001918  6000 00F0                269          BRA     MMINV   ; wrong option
0000191C  D3FC 0000000E            270  MMBYTE  ADDA.L  #14,A1  ; output will be 13 chars long + null
00001922  133C 0000                271          MOVE.B  #0,-(A1)    ; null terminator
00001926  133C 003F                272          MOVE.B  #'?',-(A1)  ; nicer output
0000192A  4281                     273          CLR.L   D1
0000192C  1210                     274          MOVE.B  (A0),D1     ; content of memory to D1
0000192E  6100 03B8                275          BSR     HEX2MEM     ; writes memory content to -8(A1)
00001932  5C89                     276          ADDA.L  #6,A1       ; we only want 2 chars, not 8
00001934  133C 0009                277          MOVE.B  #$9,-(A1)   ; a tabspace
00001938  2208                     278          MOVE.L  A0,D1       ; memory address
0000193A  6100 03AC                279          BSR     HEX2MEM     ; memory address to -8(A1)
0000193E  133C 0024                280          MOVE.B  #'$',-(A1)  ; nicer output
00001942  103C 000E                281          MOVE.B  #14,D0
00001946  4E4F                     282          TRAP    #15         ; print
00001948  103C 0002                283          MOVE.B  #2,D0
0000194C  4E4F                     284          TRAP    #15         ; read new value, if any
0000194E  0C11 0000                285          CMPI.B  #0,(A1)
00001952  6600 0006                286          BNE     MMBNEXT     ; skip memory address?
00001956  5288                     287          ADDA.L  #1,A0       ; if yes, increment A0
00001958  60C2                     288          BRA     MMBYTE      ; ...and loop
0000195A  0C11 002E                289  MMBNEXT CMPI.B  #'.',(A1)   ; else, check if done (entered '.')
0000195E  6700 00AE                290          BEQ     MMDONE
00001962  2C49                     291          MOVEA.L A1,A6       ; new value to write in!
00001964  6100 0346                292          BSR     MEM2HEX     ; store input value from A6 in D1
00001968  10C1                     293          MOVE.B  D1,(A0)+    ; put it in address location
0000196A  60B0                     294          BRA     MMBYTE      ; and loop!
0000196C  D3FC 00000010            295  MMWORD  ADDA.L  #16,A1  ; output will be 15 chars long + null
00001972  133C 0000                296          MOVE.B  #0,-(A1)
00001976  133C 003F                297          MOVE.B  #'?',-(A1)
0000197A  4281                     298          CLR.L   D1
0000197C  3210                     299          MOVE.W  (A0),D1
0000197E  6100 0368                300          BSR     HEX2MEM     ; writes memory content to -8(A1)
00001982  5889                     301          ADDA.L  #4,A1       ; we only want 4 chars, not 8
00001984  133C 0009                302          MOVE.B  #$9,-(A1)   ; a tabspace
00001988  2208                     303          MOVE.L  A0,D1
0000198A  6100 035C                304          BSR     HEX2MEM     ; memory address to -8(A1)
0000198E  133C 0024                305          MOVE.B  #'$',-(A1)
00001992  103C 000E                306          MOVE.B  #14,D0
00001996  4E4F                     307          TRAP    #15         ; print
00001998  103C 0002                308          MOVE.B  #2,D0
0000199C  4E4F                     309          TRAP    #15         ; read new value, if any
0000199E  0C11 0000                310          CMPI.B  #0,(A1)
000019A2  6600 0006                311          BNE     MMWNEXT     ; skip memory address?
000019A6  5488                     312          ADDA.L  #2,A0       ; if yes, increment A0
000019A8  60C2                     313          BRA     MMWORD      ; ...and loop
000019AA  0C11 002E                314  MMWNEXT CMPI.B  #'.',(A1)   ; else, check if done (entered '.')
000019AE  6700 005E                315          BEQ     MMDONE
000019B2  2C49                     316          MOVEA.L A1,A6       ; new value to write in!
000019B4  6100 02F6                317          BSR     MEM2HEX     ; store input value from A6 in D1
000019B8  30C1                     318          MOVE.W  D1,(A0)+    ; put it in address location
000019BA  60B0                     319          BRA     MMWORD      ; and loop!
000019BC  D3FC 00000014            320  MMLONG  ADDA.L  #20,A1  ; output will be 19 chars long + null
000019C2  133C 0000                321          MOVE.B  #0,-(A1)
000019C6  133C 003F                322          MOVE.B  #'?',-(A1)
000019CA  4281                     323          CLR.L   D1
000019CC  2210                     324          MOVE.L  (A0),D1
000019CE  6100 0318                325          BSR     HEX2MEM     ; writes memory content to -8(A1)
000019D2  133C 0009                326          MOVE.B  #$9,-(A1)   ; a tabspace
000019D6  2208                     327          MOVE.L  A0,D1
000019D8  6100 030E                328          BSR     HEX2MEM     ; memory address to -8(A1)
000019DC  133C 0024                329          MOVE.B  #'$',-(A1)
000019E0  103C 000E                330          MOVE.B  #14,D0
000019E4  4E4F                     331          TRAP    #15         ; print
000019E6  103C 0002                332          MOVE.B  #2,D0
000019EA  4E4F                     333          TRAP    #15         ; read new value, if any
000019EC  0C11 0000                334          CMPI.B  #0,(A1)
000019F0  6600 0006                335          BNE     MMLNEXT     ; skip memory address?
000019F4  5888                     336          ADDA.L  #4,A0       ; if yes, increment A0
000019F6  60C4                     337          BRA     MMLONG      ; ...and loop
000019F8  0C11 002E                338  MMLNEXT CMPI.B  #'.',(A1)   ; else, check if done (entered '.')
000019FC  6700 0010                339          BEQ     MMDONE
00001A00  2C49                     340          MOVEA.L A1,A6       ; new value to write in!
00001A02  6100 02A8                341          BSR     MEM2HEX     ; store input value from A6 in D1
00001A06  20C1                     342          MOVE.L  D1,(A0)+    ; put it in address location
00001A08  60B2                     343          BRA     MMLONG      ; and loop!
00001A0A  6100 028C                344  MMINV   BSR     INVALID
00001A0E  4CDF 0303                345  MMDONE  MOVEM.L (A7)+,D0-D1/A0-A1
00001A12  4E75                     346          RTS
00001A14                           347  
00001A14                           348  * BF -- fills block of memory with word pattern
00001A14  48E7 F170                349  BF      MOVEM.L D0-D3/D7/A1-A3,-(A7)
00001A18  121E                     350          MOVE.B  (A6)+,D1    ; first '$'
00001A1A  0C01 0024                351          CMPI.B  #$24,D1 ; is it '$'?
00001A1E  6600 0058                352          BNE     BFINV ; wrong command usage
00001A22  6100 0288                353          BSR     MEM2HEX ; D1 has 1st address in hex
00001A26  2441                     354          MOVEA.L D1,A2   ;store in A2
00001A28  121E                     355          MOVE.B  (A6)+,D1    ; space in between addresses
00001A2A  0C01 0020                356          CMPI.B  #$20,D1 ; is it ' '?
00001A2E  6600 0048                357          BNE     BFINV
00001A32  121E                     358          MOVE.B  (A6)+,D1    ; second '$'
00001A34  0C01 0024                359          CMPI.B  #$24,D1
00001A38  6600 003E                360          BNE     BFINV   
00001A3C  6100 026E                361          BSR     MEM2HEX ; D1 has 2nd address in hex
00001A40  2641                     362          MOVEA.L D1,A3   ; both addresses have been read now
00001A42  4282                     363          CLR.L   D2      ; pattern will go in here
00001A44  121E                     364          MOVE.B  (A6)+,D1    ; space before the pattern
00001A46  0C01 0000                365          CMPI.B  #$00,D1 ; no pattern given, use default
00001A4A  6700 0020                366          BEQ     BFSTART
00001A4E  0C01 0020                367          CMPI.B  #$20,D1 ; is it ' '?
00001A52  6600 0024                368          BNE     BFINV
00001A56  7603                     369          MOVE.L  #3,D3   ; counter for remaining 3 digits (if there)
00001A58  1E1E                     370  BFPATT  MOVE.B  (A6)+,D7    ; first byte of pattern
00001A5A  4A07                     371          TST.B   D7
00001A5C  6700 000E                372          BEQ     BFSTART ; only one digit was given, use first one padded with a zero
00001A60  E982                     373          ASL.L   #4,D2   ; place first digit on the left part of the byte
00001A62  6100 0274                374          BSR     ASCII2NUM
00001A66  D407                     375          ADD.B   D7,D2   ; goes into the right part of the byte
00001A68  51CB FFEE                376          DBF     D3,BFPATT   ; debrease D3 and keep looping until all digits read
00001A6C  3613                     377  BFSTART MOVE.W  (A3),D3 ; TEST: if address2 not even, address error is raised
00001A6E  B7CA                     378  BFLOOP  CMPA.L  A2,A3
00001A70  6F00 000A                379          BLE     BFDONE  ; done when A2 reaches A3
00001A74  34C2                     380          MOVE.W  D2,(A2)+    ; write the pattern in memory. Address error raised if address1 not even
00001A76  60F6                     381          BRA     BFLOOP
00001A78  6100 021E                382  BFINV   BSR     INVALID
00001A7C  4CDF 0E8F                383  BFDONE  MOVEM.L (A7)+,D0-D3/D7/A1-A3
00001A80  4E75                     384          RTS
00001A82                           385          
00001A82                           386  * BMOV -- copies block of memory somewhere else
00001A82  48E7 4038                387  BMOV    MOVEM.L D1/A2-A4,-(A7)
00001A86  121E                     388          MOVE.B  (A6)+,D1    ; first '$'
00001A88  0C01 0024                389          CMPI.B  #$24,D1 ; is it '$'?
00001A8C  6600 0046                390          BNE     BMINV ; wrong command usage
00001A90  6100 021A                391          BSR     MEM2HEX ; D1 has 1st address in hex
00001A94  2441                     392          MOVEA.L D1,A2   ;store in A2
00001A96  121E                     393          MOVE.B  (A6)+,D1    ; space in between addresses
00001A98  0C01 0020                394          CMPI.B  #$20,D1 ; is it ' '?
00001A9C  6600 0036                395          BNE     BMINV
00001AA0  121E                     396          MOVE.B  (A6)+,D1    ; second '$'
00001AA2  0C01 0024                397          CMPI.B  #$24,D1
00001AA6  6600 002C                398          BNE     BMINV   
00001AAA  6100 0200                399          BSR     MEM2HEX ; D1 has 2nd address in hex
00001AAE  2641                     400          MOVE.L  D1,A3   ; store in A3
00001AB0  121E                     401          MOVE.B  (A6)+,D1    ; space in between addresses
00001AB2  0C01 0020                402          CMPI.B  #$20,D1 ; is it ' '?
00001AB6  6600 001C                403          BNE     BMINV
00001ABA  121E                     404          MOVE.B  (A6)+,D1    ; third '$'
00001ABC  0C01 0024                405          CMPI.B  #$24,D1
00001AC0  6600 0012                406          BNE     BMINV   
00001AC4  6100 01E6                407          BSR     MEM2HEX ; D1 has 3rd address in hex
00001AC8  2841                     408          MOVE.L  D1,A4       ; store in A4
00001ACA  B7CA                     409  BMLOOP  CMPA.L  A2,A3
00001ACC  6F00 000A                410          BLE     BMDONE  ; done when A2 reaches A3
00001AD0  18DA                     411          MOVE.B  (A2)+,(A4)+ ; copy
00001AD2  60F6                     412          BRA     BMLOOP
00001AD4  6100 01C2                413  BMINV   BSR     INVALID
00001AD8  4CDF 1C02                414  BMDONE  MOVEM.L (A7)+,D1/A2-A4
00001ADC  4E75                     415          RTS
00001ADE                           416          
00001ADE                           417  * BTST -- tests each bit (by setting and unsetting all) in a block of memory
00001ADE= 4D 45 4D 4F 52 59 ...    418  BTERROR DC.B    'MEMORY ERROR FOUND AT LOCATION $00000000'
00001B06= 0A 0D                    419  BTLOC   DC.B    $A,$D ; this and BTREAD point after for HEX2MEM to work
00001B08= 56 61 6C 75 65 20 ...    420          DC.B    'Value expected: '
00001B18= 30 30 0A 0D              421  BTEXP   DC.B    '00',$A,$D
00001B1C= 56 61 6C 75 65 20 ...    422          DC.B    'Value read: 00'
00001B2A= 00                       423  BTREAD  DC.B    0
00001B2C  48E7 C070                424  BTST    MOVEM.L D0-D1/A1-A3,-(A7)
00001B30  121E                     425          MOVE.B  (A6)+,D1    ; first '$'
00001B32  0C01 0024                426          CMPI.B  #$24,D1 ; is it '$'?
00001B36  6600 00A8                427          BNE     BTINV ; wrong command usage
00001B3A  6100 0170                428          BSR     MEM2HEX ; D1 has 1st address in hex
00001B3E  2441                     429          MOVEA.L D1,A2   ; store in A2
00001B40  224A                     430          MOVEA.L A2,A1   ; store copy for BTLOOP2
00001B42  121E                     431          MOVE.B  (A6)+,D1    ; space in between addresses
00001B44  0C01 0020                432          CMPI.B  #$20,D1 ; is it ' '?
00001B48  6600 0096                433          BNE     BTINV
00001B4C  121E                     434          MOVE.B  (A6)+,D1    ; second '$'
00001B4E  0C01 0024                435          CMPI.B  #$24,D1
00001B52  6600 008C                436          BNE     BTINV   
00001B56  6100 0154                437          BSR     MEM2HEX ; D1 has 2nd address in hex
00001B5A  2641                     438          MOVE.L  D1,A3   ; store in A3
00001B5C  4281                     439          CLR.L   D1  ; needed to only look at bytes
00001B5E  B7CA                     440  BTLOOP1 CMPA.L  A2,A3   ; this loop tries bit pattern 1010
00001B60  6F00 003C                441          BLE     BTPRELOOP2
00001B64  14BC 00AA                442          MOVE.B  #$AA,(A2)   ; write
00001B68  121A                     443          MOVE.B  (A2)+,D1    ; read
00001B6A  0C01 00AA                444          CMPI.B  #$AA,D1     ; check correct
00001B6E  67EE                     445          BEQ     BTLOOP1     ; move to next byte
00001B70  43F8 1B2A                446          LEA     BTREAD,A1   ; if here, there is a problem in memory!
00001B74  6100 019A                447          BSR     HEX2MEM_NOZ ; load everything to memory, to be able to print error
00001B78  43F8 1B18                448          LEA     BTEXP,A1
00001B7C  12FC 0041                449          MOVE.B  #'A',(A1)+
00001B80  12BC 0041                450          MOVE.B  #'A',(A1)
00001B84  43F8 1B06                451          LEA     BTLOC,A1
00001B88  538A                     452          SUBA.L  #1,A2
00001B8A  220A                     453          MOVE.L  A2,D1
00001B8C  6100 015A                454          BSR     HEX2MEM
00001B90  43F8 1ADE                455          LEA     BTERROR,A1
00001B94  103C 000D                456          MOVE.B  #13,D0
00001B98  4E4F                     457          TRAP    #15     ; print the error message
00001B9A  6000 0048                458          BRA     BTDONE  ; stop execution
00001B9E  2449                     459  BTPRELOOP2  MOVEA.L A1,A2   ; copy was stored a while back to be able to start over
00001BA0  B7CA                     460  BTLOOP2 CMPA.L  A2,A3   ; this loop tries bit pattern 0101. Works the same as BTLOOP1
00001BA2  6F00 0040                461          BLE     BTDONE
00001BA6  14BC 0055                462          MOVE.B  #$55,(A2)   ; write
00001BAA  121A                     463          MOVE.B  (A2)+,D1    ; read
00001BAC  0C01 0055                464          CMPI.B  #$55,D1     ; check correct
00001BB0  67EE                     465          BEQ     BTLOOP2     ; move to next byte
00001BB2  43F8 1B2A                466          LEA     BTREAD,A1   ; error in memory, act like before
00001BB6  6100 0158                467          BSR     HEX2MEM_NOZ
00001BBA  43F8 1B18                468          LEA     BTEXP,A1
00001BBE  12FC 0035                469          MOVE.B  #'5',(A1)+
00001BC2  12BC 0035                470          MOVE.B  #'5',(A1)
00001BC6  43F8 1B06                471          LEA     BTLOC,A1
00001BCA  538A                     472          SUBA.L  #1,A2
00001BCC  220A                     473          MOVE.L  A2,D1
00001BCE  6100 0118                474          BSR     HEX2MEM
00001BD2  43F8 1ADE                475          LEA     BTERROR,A1
00001BD6  103C 000D                476          MOVE.B  #13,D0
00001BDA  4E4F                     477          TRAP    #15
00001BDC  6000 0006                478          BRA     BTDONE
00001BE0  6100 00B6                479  BTINV   BSR     INVALID
00001BE4  4CDF 0E03                480  BTDONE  MOVEM.L (A7)+,D0-D1/A1-A3
00001BE8  4E75                     481          RTS
00001BEA                           482          
00001BEA                           483  * GO -- executes another program
00001BEA  48E7 FFFF                484  GO      MOVEM.L D0-D7/A0-A7,-(A7)   ; don't allow the program to change registers
00001BEE  121E                     485          MOVE.B  (A6)+,D1    ; '$'
00001BF0  0C01 0024                486          CMPI.B  #$24,D1 ; is it '$'?
00001BF4  6600 000E                487          BNE     GOINV   ; wrong command usage
00001BF8  6100 00B2                488          BSR     MEM2HEX ; D1 has address in hex
00001BFC  2041                     489          MOVEA.L D1,A0   ;store in A0
00001BFE  4E90                     490          JSR     (A0)    ; execute the program
00001C00  6000 0006                491          BRA     GODONE
00001C04  6100 0092                492  GOINV   BSR     INVALID
00001C08  4CDF FFFF                493  GODONE  MOVEM.L (A7)+,D0-D7/A0-A7
00001C0C  4E75                     494          RTS
00001C0E                           495          
00001C0E                           496  * DF -- displays formatted registers
00001C0E  48E7 E0C0                497  DF      MOVEM.L D0-D2/A0-A1,-(A7)
00001C12  41F8 2FFC                498          LEA     STACK,A0
00001C16  5888                     499          ADDA.L  #4,A0   ; placed after A7 in stack
00001C18  43F8 164A                500          LEA     DF_MSG_END,A1
00001C1C  5389                     501  DFLOOP  SUBQ.L  #1,A1   ; pass the $A at end of each line
00001C1E  7403                     502          MOVE.L  #3,D2   ; number of registers per line - 1
00001C20  2220                     503  DFLINE  MOVE.L  -(A0),D1    ; put register value in D1
00001C22  6100 00C4                504          BSR     HEX2MEM     ; will store D1 in -8(A1)
00001C26  5989                     505          SUBQ.L  #4,A1   ; skip other characters
00001C28  51CA FFF6                506          DBF     D2,DFLINE   ; keep looping till line done       
00001C2C  B3FC 00001587            507          CMP.L   #DF_MSG,A1
00001C32  6EE8                     508          BGT     DFLOOP
00001C34  5289                     509          ADDQ.L  #1,A1   ; put back at the front of the message
00001C36  103C 000D                510          MOVE.B  #13,D0
00001C3A  4E4F                     511          TRAP    #15     ; print register value
00001C3C  4CDF 0307                512          MOVEM.L (A7)+,D0-D2/A0-A1
00001C40  4E75                     513          RTS
00001C42                           514  
00001C42                           515  * EXIT -- terminates the program
00001C42  43F8 102C                516  EXIT    LEA     GOODBYE,A1
00001C46  103C 000D                517          MOVE.B  #13,D0
00001C4A  4E4F                     518          TRAP    #15     ; print goodbye message
00001C4C  588F                     519          ADDA.L  #4,A7   ; move past the PC stored in the stack
00001C4E  DFFC 00000050            520          ADDA.L  #MAX_IN_LEN,A7  ; move stack back to position prior to reading input
00001C54  4CDF 7FFF                521          MOVEM.L (A7)+,D0-D7/A0-A6   ; restore all registers in stack
00001C58  2E78 2FFC                522          MOVEA.L STACK,A7
00001C5C  6000 23B6                523          BRA     END     ; exit program
00001C60                           524          
00001C60                           525  * The 2 extra commands:
00001C60                           526  * CONV -- takes in hex and returns decimal, or viceversa
00001C60  48E7 C040                527  CONV    MOVEM.L D0-D1/A1,-(A7)
00001C64  121E                     528          MOVE.B  (A6)+,D1
00001C66  0C01 0024                529          CMPI.B  #$24,D1 ; is it '$'?
00001C6A  6700 0016                530          BEQ     CONVH2D ; if so, hex to dec
00001C6E  538E                     531  CONVD2H SUBQ.L  #1,A6   ; point back at first number
00001C70  6100 00E2                532          BSR     MEM2DEC ; D1 contains the decimal number
00001C74  224E                     533          MOVEA.L A6,A1   ; number ready to print
00001C76  6100 0098                534          BSR     HEX2MEM_NOZ ; that number is written as hex in memory
00001C7A  133C 0024                535          MOVE.B  #'$',-(A1)
00001C7E  6000 000C                536          BRA     CONVDONE
00001C82  6100 0028                537  CONVH2D BSR     MEM2HEX ; convert ascii to hex
00001C86  224E                     538          MOVEA.L A6,A1   ;number ready to print
00001C88  6100 00F8                539          BSR     DEC2MEM ; convert it back to ascii but as decimal
00001C8C  103C 000D                540  CONVDONE MOVE.B #13,D0
00001C90  4E4F                     541          TRAP    #15 ; print result
00001C92  4CDF 0203                542          MOVEM.L (A7)+,D0-D1/A1
00001C96  4E75                     543          RTS
00001C98                           544  
00001C98                           545  *** HELPERS ***
00001C98                           546  * Print INVALID message:
00001C98  48E7 8040                547  INVALID MOVEM.L D0/A1,-(A7)
00001C9C  43F8 1068                548          LEA     INVALID_MSG,A1  ; command was invalid
00001CA0  103C 000D                549          MOVE.B  #13,D0
00001CA4  4E4F                     550          TRAP    #15     ; output invalid command
00001CA6  4CDF 0201                551          MOVEM.L (A7)+,D0/A1
00001CAA  4E75                     552          RTS
00001CAC                           553  
00001CAC                           554  * Takes X digits from (A6) in ascii and puts them in D1 as hex:
00001CAC  48E7 8100                555  MEM2HEX MOVEM.L D0/D7,-(A7)    ; store in stack
00001CB0  4281                     556          CLR.L   D1
00001CB2  1E1E                     557          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001CB4  0C07 0030                558          CMPI.B  #$30,D7
00001CB8  6D00 0016                559          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001CBC  6100 001A                560  M2HNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
00001CC0  D207                     561          ADD.B   D7,D1
00001CC2  1E1E                     562          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001CC4  0C07 0030                563          CMPI.B  #$30,D7
00001CC8  6D00 0006                564          BLT     M2HDONE ; reached some whitespace or non-numeric ascii
00001CCC  E981                     565          ASL.L   #4,D1   ; skip this the last time
00001CCE  60EC                     566          BRA     M2HNEXT ; loop again because not done
00001CD0  538E                     567  M2HDONE SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
00001CD2  4CDF 0081                568          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001CD6  4E75                     569          RTS
00001CD8                           570  
00001CD8                           571  * Takes byte in ascii in D7 and converts it to digit in D7:
00001CD8                           572  * Assumes 0-9 or A-F
00001CD8  0C07 0040                573  ASCII2NUM   CMPI.B #$40,D7
00001CDC  6D00 0004                574          BLT A2NSKIPPY
00001CE0  5F07                     575          SUBQ.B  #$7,D7   ; only for A-F
00001CE2  0407 0030                576  A2NSKIPPY   SUB.B   #$30,D7
00001CE6  4E75                     577          RTS
00001CE8                           578          
00001CE8                           579  * Takes 8 digits from D1 in hex and puts them into -8(A1) in ascii:
00001CE8  48E7 A100                580  HEX2MEM MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001CEC  4280                     581          CLR.L   D0   ; counter
00001CEE  2E01                     582  H2MNEXT MOVE.L  D1,D7
00001CF0  2400                     583          MOVE.L D0,D2
00001CF2  5342                     584  H2MRIGHT    SUBQ.W  #1,D2
00001CF4  6D00 0006                585          BLT     H2MDONE
00001CF8  E88F                     586          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001CFA  60F6                     587          BRA     H2MRIGHT
00001CFC  6100 0040                588  H2MDONE BSR     NUM2ASCII   ; convert to ascii in D7
00001D00  1307                     589          MOVE.B  D7,-(A1)
00001D02  5240                     590          ADDQ.W  #1,D0
00001D04  0C40 0008                591          CMPI.W  #8,D0
00001D08  6DE4                     592          BLT     H2MNEXT
00001D0A  4CDF 0085                593          MOVEM.L (A7)+,D0/D2/D7
00001D0E  4E75                     594          RTS
00001D10                           595          
00001D10                           596  * Takes X digits from D1 in hex and puts them into -X(A1) in ascii (no trailing zeros):
00001D10  48E7 A100                597  HEX2MEM_NOZ MOVEM.L D0/D2/D7,-(A7)    ; store in stack
00001D14  4280                     598          CLR.L   D0   ; counter
00001D16  2E01                     599  H2MZNEXT MOVE.L  D1,D7
00001D18  2400                     600          MOVE.L D0,D2
00001D1A  5342                     601  H2MZRIGHT    SUBQ.W  #1,D2
00001D1C  6D00 0006                602          BLT     H2MZDONE
00001D20  E88F                     603          LSR.L   #4,D7   ; that upper byte to lowest by -> only one left
00001D22  60F6                     604          BRA     H2MZRIGHT
00001D24  4A87                     605  H2MZDONE TST.L   D7
00001D26  6700 0010                606          BEQ     H2MZEND      ; if number done
00001D2A  6100 0012                607          BSR     NUM2ASCII   ; convert to ascii in D7
00001D2E  1307                     608          MOVE.B  D7,-(A1)
00001D30  5240                     609          ADDQ.W  #1,D0
00001D32  0C40 0008                610          CMPI.W  #8,D0
00001D36  6DDE                     611          BLT     H2MZNEXT
00001D38  4CDF 0085                612  H2MZEND  MOVEM.L (A7)+,D0/D2/D7
00001D3C  4E75                     613          RTS
00001D3E                           614  
00001D3E                           615  * Takes digit in D7 and converts it to ascii byte in D7:
00001D3E                           616  * Assumes 0-9 or A-F
00001D3E  CEBC 0000000F            617  NUM2ASCII   AND.L  #$0F,D7 ; mask and take only smallest hex digit
00001D44  0C07 000A                618          CMPI.B  #$A,D7
00001D48  6D00 0004                619          BLT N2ASKIPPY
00001D4C  5E07                     620          ADDQ.B  #$7,D7   ; only for A-F
00001D4E  0607 0030                621  N2ASKIPPY   ADD.B   #$30,D7
00001D52  4E75                     622          RTS
00001D54                           623          
00001D54                           624  * Takes X digits from (A6) in ascii and puts them in D1 as dec:
00001D54  48E7 8100                625  MEM2DEC MOVEM.L D0/D7,-(A7)    ; store in stack
00001D58  4281                     626          CLR.L   D1
00001D5A  1E1E                     627          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001D5C  0C07 0030                628          CMPI.B  #$30,D7
00001D60  6D00 0018                629          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
00001D64  6100 FF72                630  M2DNEXT BSR     ASCII2NUM   ; byte to hex digit, in D7
00001D68  D207                     631          ADD.B   D7,D1
00001D6A  1E1E                     632          MOVE.B (A6)+,D7    ; read in next byte (prime read)
00001D6C  0C07 0030                633          CMPI.B  #$30,D7
00001D70  6D00 0008                634          BLT     M2DDONE ; reached some whitespace or non-numeric ascii
00001D74  C2FC 000A                635          MULU    #10,D1   ; skip this the last time
00001D78  60EA                     636          BRA     M2DNEXT ; loop again because not done
00001D7A  538E                     637  M2DDONE  SUBA.L #1,A6   ; leave A6 pointing at byte immediately after last number
00001D7C  4CDF 0081                638          MOVEM.L (A7)+,D0/D7    ; restore from stack
00001D80  4E75                     639          RTS
00001D82                           640  
00001D82                           641  * Takes number from D1 in dec and puts them into -X(A1) in ascii:
00001D82  48E7 2100                642  DEC2MEM MOVEM.L D2/D7,-(A7)    ; store in stack
00001D86  2401                     643          MOVE.L  D1,D2
00001D88  84FC 000A                644  D2MLOOP DIVU    #10,D2
00001D8C  2E02                     645          MOVE.L  D2,D7
00001D8E  4847                     646          SWAP.W  D7
00001D90  61AC                     647          BSR     NUM2ASCII
00001D92  1307                     648          MOVE.B  D7,-(A1)
00001D94  C4BC 0000FFFF            649          AND.L   #$0000FFFF,D2 ; make sure we use only word in next divisions
00001D9A  4A42                     650          TST.W   D2
00001D9C  66EA                     651          BNE     D2MLOOP
00001D9E  4CDF 0084                652          MOVEM.L (A7)+,D2/D7
00001DA2  4E75                     653          RTS
00001DA4                           654          
00001DA4                           655  *** EXCEPTION HANDLERS ***
00001DA4  48E7 8040                656  ADDRERR MOVEM.L D0/A1,-(A7)
00001DA8  48E7 4080                657          MOVEM.L D1/A0,-(A7) ; specific for this interrupt
00001DAC  43F8 164A                658          LEA     ADDRERR_MSG,A1
00001DB0  103C 000D                659          MOVE.B  #13,D0
00001DB4  4E4F                     660          TRAP    #15
00001DB6  6000 0060                661          BRA     INTERR_REG  ; print the special registers
00001DBA  48E7 8040                662  BERR    MOVEM.L D0/A1,-(A7)
00001DBE  48E7 4080                663          MOVEM.L D1/A0,-(A7) ; specific for this interrupt
00001DC2  43F8 1663                664          LEA     BERR_MSG,A1
00001DC6  103C 000D                665          MOVE.B  #13,D0
00001DCA  4E4F                     666          TRAP    #15
00001DCC  6000 004A                667          BRA     INTERR_REG  ; print the special registers
00001DD0  48E7 8040                668  ILLINS  MOVEM.L D0/A1,-(A7)
00001DD4  43F8 1678                669          LEA     ILLINS_MSG,A1
00001DD8  6000 007C                670          BRA     INTERR 
00001DDC  48E7 8040                671  PRIVERR MOVEM.L D0/A1,-(A7)
00001DE0  43F8 1696                672          LEA     PRIVERR_MSG,A1
00001DE4  6000 0070                673          BRA     INTERR 
00001DE8  48E7 8040                674  DIV0    MOVEM.L D0/A1,-(A7)
00001DEC  43F8 16B1                675          LEA     DIV0_MSG,A1
00001DF0  6000 0064                676          BRA     INTERR 
00001DF4  48E7 8040                677  CHKERR  MOVEM.L D0/A1,-(A7)
00001DF8  43F8 16CD                678          LEA     CHKERR_MSG,A1
00001DFC  6000 0058                679          BRA     INTERR 
00001E00  48E7 8040                680  LINEA   MOVEM.L D0/A1,-(A7)
00001E04  43F8 16DE                681          LEA     LINEA_MSG,A1
00001E08  6000 004C                682          BRA     INTERR 
00001E0C  48E7 8040                683  LINEF   MOVEM.L D0/A1,-(A7)
00001E10  43F8 16F0                684          LEA     LINEF_MSG,A1
00001E14  6000 0040                685          BRA     INTERR
00001E18                           686  INTERR_REG  ; only BERR and ADDRERR do this
00001E18  204F                     687          MOVEA.L A7,A0
00001E1A  D1FC 00000018            688          ADDA.L  #24,A0  ; A0 is pointing right below SSW, BA and IR
00001E20  227C 00002FFC            689          MOVEA.L #STACK,A1
00001E26  93FC 0000003C            690          SUBA.L  #60,A1  ; write message in the input space of the stack (currently unused)
00001E2C  133C 0000                691          MOVE.B  #0,-(A1)    ; null terminator
00001E30  4281                     692          CLR.L   D1
00001E32  3220                     693          MOVE.W  -(A0),D1    ; SSW in D1
00001E34  6100 FEB2                694          BSR     HEX2MEM
00001E38  5889                     695          ADDQ.L  #4,A1       ; only want SSW to be a word
00001E3A  133C 0020                696          MOVE.B  #' ',-(A1)
00001E3E  2220                     697          MOVE.L  -(A0),D1    ; BA in D1
00001E40  6100 FEA6                698          BSR     HEX2MEM
00001E44  133C 0020                699          MOVE.B  #' ',-(A1)
00001E48  4281                     700          CLR.L   D1
00001E4A  3220                     701          MOVE.W  -(A0),D1    ; IR in D1
00001E4C  6100 FE9A                702          BSR     HEX2MEM
00001E50  5889                     703          ADDQ.L  #4,A1       ; only want IR to be a word
00001E52  4CDF 0102                704          MOVEM.L (A7)+,D1/A0 ; restore these specific registers
00001E56  103C 000D                705  INTERR  MOVE.B  #13,D0
00001E5A  4E4F                     706          TRAP    #15 ; print corresponding message for that interrupt
00001E5C  6100 FDB0                707          BSR     DF  ; print registers
00001E60  4CDF 0201                708          MOVEM.L (A7)+,D0/A1 ; do here to be able to modify values of A7
00001E64  4FF8 2FFC                709          LEA     STACK,A7    ; next 3 instructions put A7 at beginning of input space in stack
00001E68  9FFC 0000003C            710          SUBA.L  #60,A7  ; 15 registers that occupy 4 bytes each (2*4 = 8 bits)
00001E6E  9FFC 00000050            711          SUBA.L  #MAX_IN_LEN,A7  ; the input space
00001E74  6000 F8E8                712          BRA     PROMPT
00001E78                           713          
00001E78                           714  *** PROGRAM FOR TESTING GO ***    
00004000                           715      ORG $4000
00004000  227C 00004020            716          MOVEA.L #$4020,A1
00004006  22BC 48492100            717          MOVE.L  #$48492100,(A1)
0000400C  103C 000D                718          MOVE.B  #13,D0
00004010  4E4F                     719          TRAP    #15     ; print secret message
00004012  4E75                     720          RTS
00004014                           721  
00004014                           722  END
00004014                           723      END     START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2NSKIPPY           1CE2
ADDRERR             1DA4
ADDRERR_MSG         164A
ASCII2NUM           1CD8
BERR                1DBA
BERR_MSG            1663
BF                  1A14
BFDONE              1A7C
BFINV               1A78
BFLOOP              1A6E
BFPATT              1A58
BFSTART             1A6C
BMDONE              1AD8
BMINV               1AD4
BMLOOP              1ACA
BMOV                1A82
BTDONE              1BE4
BTERROR             1ADE
BTEXP               1B18
BTINV               1BE0
BTLOC               1B06
BTLOOP1             1B5E
BTLOOP2             1BA0
BTPRELOOP2          1B9E
BTREAD              1B2A
BTST                1B2C
CHKERR              1DF4
CHKERR_MSG          16CD
CMP_B               1784
COM_ADDR            10D0
COM_TABL            1095
CONV                1C60
CONVD2H             1C6E
CONVDONE            1C8C
CONVH2D             1C82
D2MLOOP             1D88
DEC2MEM             1D82
DF                  1C0E
DFLINE              1C20
DFLOOP              1C1C
DF_MSG              1587
DF_MSG_END          164A
DIV0                1DE8
DIV0_MSG            16B1
END                 4014
EXEC                179E
EXIT                1C42
GO                  1BEA
GODONE              1C08
GOINV               1C04
GOODBYE             102C
H2MDONE             1CFC
H2MNEXT             1CEE
H2MRIGHT            1CF2
H2MZDONE            1D24
H2MZEND             1D38
H2MZNEXT            1D16
H2MZRIGHT           1D1A
HELP                17AC
HELP_MSG            10E6
HELP_MSG2           1398
HEX2MEM             1CE8
HEX2MEM_NOZ         1D10
ILLINS              1DD0
ILLINS_MSG          1678
INTERR              1E56
INTERR_REG          1E18
INVALID             1C98
INVALID_MSG         1068
LINEA               1E00
LINEA_MSG           16DE
LINEF               1E0C
LINEF_MSG           16F0
M2DDONE             1D7A
M2DNEXT             1D64
M2HDONE             1CD0
M2HNEXT             1CBC
MAX_IN_LEN          50
MDSP                17D0
MDSPADDR2           17F8
MDSPDONE            1848
MDSPINV             1844
MDSPLOOP            1808
MEM2DEC             1D54
MEM2HEX             1CAC
MM                  18D6
MMBNEXT             195A
MMBYTE              191C
MMDONE              1A0E
MMINV               1A0A
MMLNEXT             19F8
MMLONG              19BC
MMWNEXT             19AA
MMWORD              196C
N2ASKIPPY           1D4E
NUM2ASCII           1D3E
PRIVERR             1DDC
PRIVERR_MSG         1696
PROMPT              175E
PROMPT_STR          105A
SEARCH              177A
SORTW               184E
SORTWA              18AA
SORTWCMP            18A4
SORTWD              18B4
SORTWDEF            18A0
SORTWDONE           18D0
SORTWINV            18CC
SORTWLOOP           18A2
SORTWNEXT           18BA
SORTWSWAP           18C4
STACK               2FFC
START               1702
WELCOME             1000
